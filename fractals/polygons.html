[N1]Demo[/N1]
[HTML]<table>
	<tbody>
		<tr>
			<td>Vertices <3-10></td>
			<td>Depth <1-10></td>
			<td>Max. Vert<sup>Depth</sup></td>
			<td>Speed (ms) <1-50></td>
			<td>Length multiplier <0.2-0.7></td>
			<td></td>
		</tr>
		<tr>
			<td><input id="verticesInput" style="width: 80px;" value="6"></td>
			<td><input id="depthInput" style="width: 80px;" value="6"></td>
			<td>10<sup>6</sup> vertices</td>
			<td><input id="speedInput" style="width: 120px;" value="50"></td>
			<td><input id="lengthInput" style="width: 140px;" value="0.35"></td>
			<td><button type="button" onclick="$.fractalPolygon.start()">Run!</button></td>
		</tr>
	</tbody>
</table>
<div><canvas id="myCanvas" width="700" height="600"></canvas></div>[/HTML]
<script>
let $ = {};
$.fractalPolygon = (function() {
	/**
	 * https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
	 * https://stackoverflow.com/questions/17433015/change-the-hue-of-a-rgb-color-in-javascript
	 * Converts an HSL color value to RGB. Conversion formula
	 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
	 * Assumes h, s, and l are contained in the set [0, 1] and
	 * returns r, g, and b in the set [0, 255].
	 *
	 * @param   {number}  h       The hue
	 * @param   {number}  s       The saturation
	 * @param   {number}  l       The lightness
	 * @return  {Array}           The RGB representation
	 */
	let hslToRGB = function(h, s, l) {
	    let r, g, b;

	    if (s == 0) {
	        r = g = b = l; // achromatic
	    } else {
	        let hue2rgb = function hue2rgb(p, q, t){
	            if(t < 0) t += 1;
	            if(t > 1) t -= 1;
	            if(t < 1/6) return p + (q - p) * 6 * t;
	            if(t < 1/2) return q;
	            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	            return p;
	        }

	        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        let p = 2 * l - q;
	        r = hue2rgb(p, q, h + 1/3);
	        g = hue2rgb(p, q, h);
	        b = hue2rgb(p, q, h - 1/3);
	    }

	    return "#" + ((1 << 24) + (Math.round(r * 255) << 16) + ( Math.round(g * 255) << 8) + Math.round(b * 255)).toString(16).slice(1);
	};
	
	let toRad = function(angle) {
		return Math.PI * angle / 180;	
	};

	// konfigurace
	let maxDepth;
	let depth;
	let vertexCount;
	let startLength;
	let lengthMultiplier;
	let interval = 100;
	let hueStep;
	
	let canvas = document.getElementById("myCanvas");
	let ctx = canvas.getContext("2d");

	let width = canvas.width;
	let height = canvas.height;
	let xCenter = width / 2;
	let yCenter = height / 2;

	let innerIntervalCallback;

	let drawLevel = function(level, x, y, length, sourceVertex) {
	
		let harmonicColor = hslToRGB(
			hueStep * level,
			0.9,
			0.5
		);
		ctx.strokeStyle = harmonicColor;
		ctx.fillStyle = harmonicColor;
		
		let angle = toRad(360 / vertexCount);
		let newVertices = [];
	
		ctx.beginPath();		
		for (var i=0; i < vertexCount; i++) {
			let vx = x + Math.cos(angle * i) * length;
			let vy = y + Math.sin(angle * i) * length;
			newVertices[i] = [vx, vy];
			if (i == 0)
				ctx.moveTo(vx, vy);
			else
				ctx.lineTo(vx, vy);
		}
		ctx.lineTo(newVertices[0][0], newVertices[0][1]);
		ctx.fill();

		if (level + 1 == depth)
			return;

		for (var i=0; i < vertexCount; i++) {
			if (level != 0 && Math.abs(sourceVertex - i) == vertexCount / 2)
				continue;
			drawLevel(level + 1, newVertices[i][0], newVertices[i][1], length * lengthMultiplier, i);
		}
		
	};
	
	let innnerChangeInterval = function(value) {
		if (isNaN(value))
			return;
		let newValue = Number(value);
		if (newValue < 1)
			return;
		if (interval) 
			console.log("interval changed from '" + interval + "' to '" + newValue + "'");
		interval = newValue;
		
		if (innerIntervalCallback) 
			clearInterval(innerIntervalCallback);
		
		innerIntervalCallback = setInterval(function() {
			ctx.clearRect(depth++, 0, width, height);		
			drawLevel(0, xCenter, yCenter, startLength);
			if (depth == maxDepth)
				clearInterval(innerIntervalCallback);
		}, interval);
	};

	let validate = function(msg, field, min, max) {
		let value = document.getElementById(field).value;
		if (isNaN(value)) {
			alert(msg);
			return false;
		}
		value = Number(value);
		if (value < min || value > max) {
			alert(msg);
			return false;
		}
		return value;
	};

	return {
		start: function() {
			let verticesParam = validate("Invalid vertices", "verticesInput", 3, 10);
			let depthParam = validate("Invalid depth", "depthInput", 1, 12);
			let speedParam = validate("Invalid speed", "speedInput", 1, 50);
			let lengthPerLevelParam = validate("Invalid length", "lengthInput", 0.2, 0.7);			

			if (verticesParam && depthParam && speedParam && lengthPerLevelParam) {
				if (Math.pow(verticesParam, depthParam) >= Math.pow(10,6)) {
					alert("Invalid vertices^depth");
					return;
				}

				vertexCount = verticesParam;
				maxDepth = depthParam;			
				depth = 0;
				hueStep = 1 / maxDepth;
				startLength = 170;
				lengthMultiplier = lengthPerLevelParam; 
				innnerChangeInterval(speedParam);
			}
		}
	};

})();

$.fractalPolygon.start();</script>