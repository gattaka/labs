[N1]Popis[/N1]
Run-length encoding (RLE) je jedním z nejjednodušších způsobů, jak komprimovat obsah. Během komprese se přepisuje původní posloupnost položek obsahu jako jejich počet a typ položky. Aby byla komprese efektivní, je potřeba, aby obsah měl dostatek "skupin" -- tedy více položek stejného typu za sebou. Pokud má každá položka jiný typ, komprese se moc neprojeví nebo může v krajním případě mít i opačný efekt -- výsledný soubor bude větší než originál.

Jako příklad jde vzít bitmapu -- každý pixel je dán RGB hodnotou, takže jde o 3x8 bitů na pixel. Pokud budu mít bitmapu s rozlišením 8x8, mám hrubý záznam o 1536 bitů.

[HTML]<div style="text-align:center"><canvas id="imgCanvas" width="700" height="100"></canvas></div>
<br/>
<span id="rawSpan"></span>
<div style="text-align:center"><canvas id="rawCanvas" width="700" height="100"></canvas></div>[/HTML]

Pokud by se RLE použilo přímo na komprimování souboru bitů (bez dalších informací) a pro zápis počtu stejných bitů za sebou by se použil například Elias gamma kódování, byl by výsledek dost na nic, protože by se objem souboru zvětšil:

[HTML]<span id="comBitSpan"></span>
<div style="text-align:center"><canvas id="comBitCanvas" width="700" height="100"></canvas></div>
<br/>
<span id="decBitSpan"></span>
<div style="text-align:center"><canvas id="decBitCanvas" width="700" height="100"></canvas></div>[/HTML]

Proto je potřeba kompresi povádět ve smyslu barev (položek) -- jde tak rozpoznat opakování, na základě kterých se pak uvedou jenom počty. Bitový zápis barev je stejný a jejich počet (pixely) je opět pomocí Elias kódování:

[HTML]<span id="comPxSpan"></span>
<div style="text-align:center"><canvas id="comPxCanvas" width="700" height="100"></canvas></div>
<br/>
<div style="text-align:center"><canvas id="decImgCanvas" width="700" height="100"></canvas></div>[/HTML]
<script>var $ = $ || {};
$.rle = (function() {

	let colors;
	let size = 8;
	let bitSize = 5;
	let pxSize = 10;
	let width = 700;
	
	let innnerChangeInterval = function(value) {
		if (isNaN(value))
			return;
		let newValue = Number(value);
		if (newValue < 1)
			return;
		console.log("interval changed from '" + interval + "' to '" + newValue + "'");
		interval = newValue;
		
		if (innerIntervalCallback) 
			clearInterval(innerIntervalCallback);
		
		innerIntervalCallback = setInterval(function() {
			step();
		}, interval);
	};
	
	let toBinary = function(number, powStart) {
		let pow = powStart ? powStart : Math.pow(2, Math.floor(Math.log(number) / Math.log(2)));
		let result = [];
		while (pow > 0) {
			result.push((number & pow) >= 1 ? 1 : 0);			
			pow = pow >> 1;
		}
		return result;
	};
	
	let toDecimal = function(binary) {
		let result = 0;
		let pow = 1 << (binary.length - 1);
		for (let i = 0; i < binary.length; i++) {
			if (binary[i] == 1)
				result += pow;
			pow = pow >> 1;
		}
		return result;
	}
	
	let encodeElias = function(number) {
		let binary = toBinary(number);
		let result = [];
		for (let i = 0; i < binary.length - 1; i++)
			result[i] = 0;
		return result.concat(binary);
	};
	
	let draw = function(canvasId, data) {
		let canvas = document.getElementById(canvasId);
		let ctx = canvas.getContext("2d");		
		let height = Math.ceil(data.length / (width / bitSize)) * bitSize; 
		canvas.height = height;
				
		ctx.strokeStyle = "#333";
		ctx.clearRect(0, 0, width, height);
		ctx.strokeRect(0, 0, width, height);		
		
		let x = 0;
		let y = 0;
		for (let i = 0; i < data.length; i++) {			
			ctx.fillStyle = data[i] == 1 ? "#888" : "white";	
			ctx.fillRect(x, y, bitSize, bitSize);
			ctx.strokeRect(x, y, bitSize, bitSize);
			x += bitSize;
			if (x >= width) {
				x = 0;
				y += bitSize;
			}
		}	
	};
	
	let randomColor = function() {
		return colors[Math.floor(Math.random() * colors.length)];
	};
		
	let drawImg = function(canvasId, img) {
		let canvas = document.getElementById(canvasId);
		let ctx = canvas.getContext("2d");		
		let width = size * pxSize; 
		canvas.width = width;
		let height = size * pxSize; 
		canvas.height = height;
				
		ctx.strokeStyle = "#333";
		ctx.clearRect(0, 0, width, height);
		ctx.strokeRect(0, 0, width, height);		
		
		let x = 0;
		let y = 0;
		for (let i = 0; i < img.length; i++) {			
			// https://www.w3schools.com/cssref/css_colors_legal.asp
			ctx.fillStyle = "rgb(" + img[i][0] + ", " + img[i][1] + ", " + img[i][2] + ")";
			ctx.fillRect(x, y, pxSize, pxSize);
			ctx.strokeRect(x, y, pxSize, pxSize);
			x += pxSize;
			if (x >= width) {
				x = 0;
				y += pxSize;
			}
		}	
	};
		
	let createImg = function() {
		// init colors
		colors = [];
		for (let c = 0; c < 10; c++)
			colors.push([
				Math.floor(Math.random() * 256),
				Math.floor(Math.random() * 256),
				Math.floor(Math.random() * 256)
			]);
	
		let img = [];
		let lastColor = randomColor();
		for (let i = 0; i < size * size; i++) {
			if (Math.random() > 0.8)
				lastColor = randomColor();
			img.push(lastColor);
		}
	
		drawImg("imgCanvas", img);
		return img;
	};
	
	let serializeColor = function(color) {
		let result = [];
		for (let p = 0; p < 3; p++)
			result = result.concat(toBinary(color[p], 128));
		return result;
	};
	
	let deserializeColor = function(rgbBits) {
		let result = [];
		for (let i = 0; i < 3; i++) {
			result[i] = 0;
			let pow = 128;
			for (let p = 0; p < 8; p++) {
				if (rgbBits[i][p] == 1)
					result[i] += pow;
				pow = pow >> 1;
			}
		}
		return result;
	};
	
	let compressBitwise = function(data) {
		// první znak musí být znak dat, aby bylo dáno čím se začíná
		// jestli 0 nebo 1 -- zbytek už bude jenom přepínání
		let compressed = [data[0]];			
		let last = 0;
		for (let i = 1; i < data.length; i++) {
			if (data[last] != data[i]) {
				compressed = compressed.concat(encodeElias(i - last));
				last = i;
			}
		}
		compressed = compressed.concat(encodeElias(data.length - last));
		draw("comBitCanvas", compressed);
		let ratio = compressed.length / data.length * 100;
		document.getElementById("comBitSpan").innerText = "Compressed (bitwise) " + compressed.length + " bits (" + ratio.toPrecision(4) + "%)";
		return compressed;
	};
	
	let decompressBitwise = function(compressed) {
		let decompressed = [];
		// jakým znakem se začíná
		let current = compressed[0];
		for (let i = 1; i < compressed.length;) {
			let places = 1;
			while (compressed[i] == 0) {
				places++;
				i++;				
			}
			let binary = [];
			for (let b = 0; b < places; b++)
				binary.push(compressed[i++]);							
			let count = toDecimal(binary);
			for (let b = 0; b < count; b++)
				decompressed.push(current);							
			current = current == 1 ? 0 : 1;
		}
		draw("decBitCanvas", decompressed);
		document.getElementById("decBitSpan").innerText = "Decompressed (bitwise) " + decompressed.length + " bits";		
	};
	
	let compressPixelwise = function(img, dataLen) {
		let pxCompressed = [];			
		let last = 0;
		for (let i = 1; i < img.length; i++) {
			if (img[last][0] != img[i][0] 
				|| img[last][1] != img[i][1] 
				|| img[last][2] != img[i][2]) {
				pxCompressed = pxCompressed.concat(encodeElias(i - last)).concat(serializeColor(img[last]));
				last = i;
			}
		}
		pxCompressed = pxCompressed.concat(encodeElias(img.length - last)).concat(serializeColor(img[last]));
		draw("comPxCanvas", pxCompressed);
		let ratio = pxCompressed.length / dataLen * 100;
		document.getElementById("comPxSpan").innerText = "Compressed (pixelwise) " + pxCompressed.length + " bits (" + ratio.toPrecision(4) + "%)";
		return pxCompressed;
	};

	let decompressPixelwise = function(compressed) {
		let decompressed = [];
		let current = [];
		for (let i = 0; i < compressed.length;) {
			let places = 1;
			while (compressed[i] == 0) {
				places++;
				i++;				
			}
			let binary = [];
			for (let b = 0; b < places; b++)
				binary.push(compressed[i++]);							
			let count = toDecimal(binary);
			let rgbBits = [];
			for (let p = 0; p < 3; p++) {
				rgbBits[p] = [];
				for (let b = 0; b < 8; b++)
					rgbBits[p].push(compressed[i++]);							
			}
			let color = deserializeColor(rgbBits);
			for (let b = 0; b < count; b++)
				decompressed.push(color);
		}
		drawImg("decImgCanvas", decompressed);
	};
	
	let init = function() {	
		// test
		serializeColor([0, 2, 255]);
	
		let img = createImg();
		let data = [];
		for (let i = 0; i < img.length; i++)			
			data = data.concat(serializeColor(img[i]));
		draw("rawCanvas", data);
		document.getElementById("rawSpan").innerText = "Input " + data.length + " bits";
		
		// https://en.wikipedia.org/wiki/Run-length_encoding
		// https://stackoverflow.com/questions/7598705/binary-run-length-encoding
		// https://en.wikipedia.org/wiki/Elias_gamma_coding
		
		let bitCompressed = compressBitwise(data);	
		decompressBitwise(bitCompressed);
		
		let pxCompressed = compressPixelwise(img, data.length);
		decompressPixelwise(pxCompressed);		
	};	
		
	return {

		start: function() {					
			init();						
		},
		
	};

})();

$.rle.start();</script>

[SOURCES]https://en.wikipedia.org/wiki/Elias_gamma_coding
https://stackoverflow.com/questions/7598705/binary-run-length-encoding
https://en.wikipedia.org/wiki/Run-length_encoding[/SOURCES]