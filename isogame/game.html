[HTML]<head>
	<script type="text/javascript" src="../libs/astar.js"></script>	
	<script type="text/javascript" src="./SpriteLoader.js"></script>
	<script type="text/javascript" src="./LevelLoader.js"></script>
	<script type="text/javascript" src="./GFXUtils.js"></script>
	<script type="text/javascript" src="./GFXMinimap.js"></script>
	<script type="text/javascript" src="./IsoRenderer.js"></script>	
	<script type="text/javascript" src="./Configuration.js"></script>		
</head>
<input type="checkbox" onchange="$.GIsoGame.Game.changeCentered(this.checked)" style="width: 80px;" checked>Centered?</input>
<input type="checkbox" onchange="$.GIsoGame.Game.changeOutlines(this.checked)" style="width: 80px;" checked>Outlines?</input>
<div style="margin: 10px 0;">
	<canvas id="canvasT" width="1024" height="600"></canvas>
</div>[/HTML]
<script>
var $ = $ || {};
$.GIsoGame = $.GIsoGame || {};
$.GIsoGame.Game = (function() {

	let canvas = document.getElementById("canvasT");
	let ctx = canvas.getContext("2d");
	let width = canvas.width;
	let height = canvas.height;	
	let halfWidth = width / 2;
	let halfHeight = height / 2;
	
	let spriteLoader;
	let levelLoader;
	let currentLevel;
	let isoRenderer;
	
	let lastTime = 0;
	
	let viewX = 0;
	let viewY = 0;
	
	let cellW = 64;
	let cellH = 32;	
	
	let mousedown = false;
	
	// Stance (4 frames)
	// Walk (8 frames)
	// Attack (4 frames)
	// Cast (4 frames)
	// Block (2 frames)
	// Hit and Die (6 frames)
	// Aim Crossbow (4 frames)
	let heroSprite = {
		width: 128,
		height: 128,		
		directionFrames: 32,
		// počáteční frame animací
		loops: [0, 4, 8, 4, 4, 2, 6],
		// počty frame animací
		loopsFrames: [4, 8, 4, 4, 2, 6, 4],
		loopsMirror: [true, false, false, false, false, false, false],
		currentFrame: 0,
		currentLoop: 0,
		// krok v rámci smyčky -- není to samé jako frame, protože
		// pokud jde o smyčku, která se zrcadlí, bude kroků 2x víc,
		// než má fyzicky smyčka snímků
		currentLoopStep: 0,
		// délka trvání frame
		delay: 100,
		// inkrement času
		timer: 0,
		// virtuální isometrické souřadnice
		// nejsou reálné, protože pokud bude postava uprostřed plochy,
		// nebudou se jeho reálné souřadnice měnit, ale je potřeba nějak
		// evidovat "posun" k cíli -- šlo by napevno postavu přilepit na
		// střed a posouvat jenom podklad, ale takhle je to obecnější a 
		// lze to jednoduše použít i na ostatní objekty/postavy, které 
		// nebudou ve středu, nebo pokud se postava na okraji mapy posune
		// mimo střed
		vix: 0,
		viy: 0,		
	};
	
	let hero = {
		mx: 0, 
		my: 0,
		speed: 0.2,	
		direction: 0
	};
	
	let target = {
		mx: 0, 
		my: 0,
		vix: 0,
		viy: 0,
		currentStep: 0,		
		mxSteps: [],
		mySteps: [],
		vixSteps: [],
		viySteps: [],
	};	
	
	let cursor = {
		mx: 0, 
		my: 0,
		vix: 0,
		viy: 0,		
	};		

	/*
	* DRAWING
	*/	
	
	let drawHero = function() {							
		let heroSpriteAdjustedX = Math.floor(heroSprite.vix + viewX);
		let heroSpriteAdjustedY = Math.floor(heroSprite.viy + viewY);
		isoRenderer.drawSprite(1, 0, heroSprite.currentFrame, heroSpriteAdjustedX, heroSpriteAdjustedY, $.GIsoGame.Configuration.outlines);	
		if ($.GIsoGame.Configuration.outlines) 
			$.GIsoGame.GFXUtils.drawPoint(ctx, heroSpriteAdjustedX, heroSpriteAdjustedY, "lime");			
	};
	
	let drawTarget = function() {							
		if ($.GIsoGame.Configuration.outlines)
			$.GIsoGame.GFXUtils.drawPoint(ctx, Math.floor(target.vix + viewX), Math.floor(target.viy + viewY), "yellow");			
	};
	
	let onCellRenderFunc = function(mx, my) {
		if (Math.floor(target.mx) == mx && Math.floor(target.my) == my)
			drawTarget();
		if (Math.floor(hero.mx) == mx && Math.floor(hero.my) == my)
			drawHero();
	};
	
	let adjustView = function() {
		if ($.GIsoGame.Configuration.centered) {
			viewX = halfWidth - heroSprite.vix;
			viewY = halfHeight - heroSprite.viy;
		}
	};		
		
	let draw = function(timestamp) {
		drawScene(timestamp);
		window.requestAnimationFrame(draw);
	};
			
	let drawScene = function(timestamp) {	
		if (!spriteLoader.isLoaded())
			return;
			
		// Update času pro animace
		let delay = timestamp - lastTime;
		lastTime = timestamp;
		
		animateHero(delay);
		
		isoRenderer.update(delay, viewX, viewY);

		$.GIsoGame.GFXMinimap.drawMinimap(ctx, currentLevel, target, hero);
	};		

	/*
	* ANIMATION
	*/
	
	let nextTargetStep = function() {
		if (target.currentStep == -1)
			return false;
		target.mx = target.mxSteps[target.currentStep];
		target.my = target.mySteps[target.currentStep];
		target.vix = target.vixSteps[target.currentStep];
		target.viy = target.viySteps[target.currentStep];		
		target.currentStep--;	
		return true;
	};
	
	let animateHero = function(delay) {
		heroSprite.timer += delay;				
		
		let diffX = target.vix - heroSprite.vix;
		let diffY = heroSprite.viy - target.viy;
		// aby to byl kruh, je potřebau diffY kompenzovat isometrické zkosení 1:2
		let angle = Math.atan(diffY * 2 / diffX) / Math.PI * 180;
		if (diffX >= 0 && diffY > 0) {
			// ok
		} else if (diffX < 0) {
			angle += 180;
		} else {
			angle += 360;		
		}
		
		if (diffX != 0 || diffY != 0) {
			let shiftX = 0;
			let shiftY = 0;			
			let rad = angle / 180 * Math.PI;
			shiftX = Math.cos(rad) * delay * hero.speed;
			// isometrické zkosení 1:2 musí snížit i rychlost
			shiftY = Math.sin(rad) / 2 * delay * hero.speed;
			// jde se proti směru
			shiftX *= -1;
			shiftY *= -1;
			let reductionX = diffX + shiftX;
			let reductionY = diffY + shiftY;
			if (Math.sign(reductionX) != Math.sign(diffX) || reductionX == 0) {
				heroSprite.vix = target.vix;
			} else {
				heroSprite.vix = heroSprite.vix - shiftX;
			}						
			if (Math.sign(reductionY) != Math.sign(diffY) || reductionY == 0) {
				heroSprite.viy = target.viy;
			} else {
				heroSprite.viy = heroSprite.viy + shiftY;
			}
			
			heroSprite.currentLoop = 1;
			
			let tolerancex = 10;
			let tolerancey = tolerancex;
			
			if (angle >= 0 && angle <= tolerancex || angle > (360 - tolerancex) && angle <= 360) {
				hero.direction = 4; // right
			} else if (angle > tolerancex && angle <= (90 - tolerancey)) {
				hero.direction = 3; // right up
			} else if (angle > (90 - tolerancey) && angle <= (90 + tolerancey)) {
				hero.direction = 2; // up
			} else if (angle > (90 + tolerancey) && angle <= (180 - tolerancex)) {
				hero.direction = 1; // left up
			} else if (angle > (180 - tolerancex) && angle <= (180 + tolerancex)) {
				hero.direction = 0; // left
			} else if (angle > (180 + tolerancex) && angle <= (270 - tolerancey)) {
				hero.direction = 7; // left down
			} else if (angle > (270 - tolerancey) && angle <= (270 + tolerancey)) {
				hero.direction = 6; // down
			} else /* if (angle > 280 && angle <= 330) */ {
				hero.direction = 5; // right down
			}	

			adjustView();			
						
			mapCoord = isoRenderer.toMap(heroSprite.vix, heroSprite.viy);			
			hero.mx = mapCoord.mx;
			hero.my = mapCoord.my;
			
			/*
			console.log("viewX: " + viewX);
			console.log("viewY: " + viewY);			
			console.log("target.vix: " + target.vix);
			console.log("target.viy: " + target.viy);
			console.log("heroSprite.vix: " + heroSprite.vix);
			console.log("heroSprite.viy: " + heroSprite.viy);
			console.log("mx: " + hero.mx + " my: " + hero.my);
			*/
			
		} else {
			if (!nextTargetStep())
				heroSprite.currentLoop = 0;
		}		
		
		let isMirrorLoop = heroSprite.loopsMirror[heroSprite.currentLoop];
		let loopFrames = heroSprite.loopsFrames[heroSprite.currentLoop];
		let loopVirtualFrames = isMirrorLoop ? loopFrames * 2 : loopFrames;		
		
		let stepShift = Math.floor(heroSprite.timer / heroSprite.delay);
		if (stepShift > 0)
			heroSprite.timer -= stepShift * heroSprite.delay;			
		heroSprite.currentLoopStep = (heroSprite.currentLoopStep + stepShift) % loopVirtualFrames;
		
		let currentFrame = heroSprite.currentLoopStep;
		if (isMirrorLoop && currentFrame > loopFrames - 1) 
			currentFrame = loopFrames - 1 - currentFrame % loopFrames;		
			
		heroSprite.currentFrame = heroSprite.directionFrames * hero.direction + heroSprite.loops[heroSprite.currentLoop] + currentFrame;	
	};
	
	/*
	* PATHFINDING
	*/		
	
	let isCollision = function(mx, my) {
		return mx < 0 || mx >= currentLevel.getMapW() 
			|| my < 0 || my >= currentLevel.getMapH() 
			|| currentLevel.getWallAtCoord(Math.floor(mx), Math.floor(my)) != undefined;
	};
	
	let prepareNavigationSteps = function(mx, my, ix, iy) {
		// krok v pořadí od cíle k počátku
		let heuristicFunc = function(aPoint, bPoint) {
			return Math.sqrt(Math.pow(aPoint.mx - bPoint.mx, 2) + Math.pow(aPoint.my - bPoint.my, 2));
		};	
		
		let distanceFunc = function(aPoint, bPoint) {			
			return 1;
		};
		
		let neighborsFunc = function(point) {
			let neighbors = [];
			if (!isCollision(point.mx - 1, point.my)) {
				// left
				neighbors.push({mx: point.mx - 1, my: point.my, id: point.id - 1});	
				// top left
				if (!isCollision(point.mx - 1, point.my - 1)) 
					neighbors.push({mx: point.mx - 1, my: point.my - 1, id: point.id - currentLevel.getMapW() - 1});	
				// bottom left
				if (!isCollision(point.mx - 1, point.my + 1))
					neighbors.push({mx: point.mx - 1, my: point.my + 1, id: point.id + currentLevel.getMapW() - 1});	
			}
			if (!isCollision(point.mx + 1, point.my)) {
				// right				
				neighbors.push({mx: point.mx + 1, my: point.my, id: point.id + 1});	
				// top right
				if (!isCollision(point.mx + 1, point.my - 1)) 					
					neighbors.push({mx: point.mx + 1, my: point.my - 1, id: point.id - currentLevel.getMapW() + 1});	
				// bottom right
				if (!isCollision(point.mx + 1, point.my + 1)) 
					neighbors.push({mx: point.mx + 1, my: point.my + 1, id: point.id + currentLevel.getMapW() + 1});	
			}
			// top
			if (!isCollision(point.mx, point.my - 1)) 
				neighbors.push({mx: point.mx, my: point.my - 1, id: point.id - currentLevel.getMapW()});	
			// bottom
			if (!isCollision(point.mx, point.my + 1)) 
				neighbors.push({mx: point.mx, my: point.my + 1, id: point.id + currentLevel.getMapW()});	
			return neighbors;
		};
				
		let pointA = {};
		pointA.mx = Math.floor(hero.mx);
		pointA.my = Math.floor(hero.my);
		pointA.id = pointA.mx + pointA.my * currentLevel.getMapW();		
		
		let pointB = {};
		pointB.mx = Math.floor(mx);
		pointB.my = Math.floor(my);
		pointB.id = pointB.mx + pointB.my * currentLevel.getMapW();

		target.steps = $.GJSLibAStar.findPath(pointA, pointB, heuristicFunc, distanceFunc, neighborsFunc);		
		//console.log("A* steps: " + target.steps);

		// 0. cílový doplňuji sám, protože z A* vypadnou středové
		// souřadnice a já chci dojít přímo k offsetovým hodnotám
		// dle toho, jak se na počátku nezaokrouhleně zadalo
		target.mxSteps = [mx];
		target.mySteps = [my];
		target.vixSteps = [ix];
		target.viySteps = [iy];
		
		// poslední krok nechci, protože na něm už stojím
		for (let i = 0; i < target.steps.length - 1; i++) {
			let smx = target.steps[i].mx + 0.5;
			let smy = target.steps[i].my + 0.5;
			let siso = isoRenderer.toIso(smx, smy);
			target.mxSteps.push(smx);
			target.mySteps.push(smy);
			target.vixSteps.push(siso.ix);
			target.viySteps.push(siso.iy);
		}
		
		target.currentStep = target.mxSteps.length - 1;
		nextTargetStep();
	};
	
	let updateTarget = function(e) {		
		if (!isCollision(cursor.mx, cursor.my))
			prepareNavigationSteps(cursor.mx, cursor.my, cursor.vix, cursor.viy);		
	};
	
	/*
	* INIT
	*/	
	
	let init = function() {							
		currentLevel = $.GIsoGame.LevelLoader.createLevel();
		
		spriteLoader = $.GIsoGame.SpriteLoader.create();
		spriteLoader.queueTexture(0, "https://www.gattserver.cz/fm-files/isometric-files/ground/grass_medium_64x32.png", 8, 7, cellW, cellH, 0, 0);
		spriteLoader.queueTexture(0, "https://www.gattserver.cz/fm-files/isometric-files/ground/stone_path_64x32.png", 8, 7, cellW, cellH, 0, 0);			
		spriteLoader.queueTexture(0, "https://www.gattserver.cz/fm-files/isometric-files/ground/grass_dry_64x32.png", 8, 7, cellW, cellH, 0, 0);
		spriteLoader.queueTexture(1, "https://www.gattserver.cz/fm-files/isometric-files/characters/skeleton_0.png", 32, 8, heroSprite.width, heroSprite.height, 64, 128 - 32);
		//spriteLoader.queueTexture(1, "https://www.gattserver.cz/fm-files/isometric-files/characters/skeleton_0.png", 32, 8, heroSprite.width, heroSprite.height, 0, 0);
		spriteLoader.queueTexture(2, "https://www.gattserver.cz/fm-files/isometric-files/plants/weed03.png", 1, 1, 128, 64, 0, 16);
		spriteLoader.queueTexture(2, "https://www.gattserver.cz/fm-files/isometric-files/plants/swirl02.png", 1, 1, 128, 64, 0, 16);
		spriteLoader.queueTexture(3, "https://www.gattserver.cz/fm-files/isometric-files/walls/iso_dungeon_walls_by_pfunked.png", 8, 4, 128, 128, 32, 64 + 16);
		spriteLoader.queueTexture(3, "https://www.gattserver.cz/fm-files/isometric-files/plants/pine-none03.png", 1, 1, 256, 256, 64 + 42, 128 + 64);
		spriteLoader.queueTexture(3, "https://www.gattserver.cz/fm-files/isometric-files/walls/barricade_tiles.png", 4, 3, 128, 128, 32, 64 + 16);
		
		spriteLoader.load();
			
		isoRenderer = $.GIsoGame.IsoRenderer.create(ctx, width, height, cellW, cellH, currentLevel, spriteLoader, cursor, onCellRenderFunc);
		
		let mx = 2.5;
		let my = 1.5;
		hero.mx = mx;
		hero.my = my;
		target.mx = mx;
		target.my = my;
		
		viewX = 0;
		viewY = 0;
		
		let iso = isoRenderer.toIso(mx, my);
		target.vix = Math.floor(iso.ix);
		target.viy = Math.floor(iso.iy);
		heroSprite.vix = target.vix;
		heroSprite.viy = target.viy;	
		viewX = halfWidth - target.vix;
		viewY = halfHeight - target.viy;
		prepareNavigationSteps(mx, my, target.vix, target.viy); 
						
		// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas
		// https://www.html5rocks.com/en/tutorials/canvas/performance/#toc-ref
		// https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
		// https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame
		window.requestAnimationFrame(draw);		
	};		
	
	canvas.addEventListener("mousedown", function (e) {
		mousedown = true;
		updateTarget(e);
	}, false);
 
	canvas.addEventListener("mouseup", function (e) {
		mousedown = false;
	}, false);
	
	canvas.addEventListener("mouseleave", function (e) {
		mousedown = false;
	}, false);
	
	canvas.addEventListener("mousemove", function (e) {
		let bound = canvas.getBoundingClientRect();
		let targetX = e.clientX - bound.x;
		let targetY = e.clientY - bound.y;			
		let ix = targetX - viewX;
		let iy = targetY - viewY;
		mapCoord = isoRenderer.toMap(ix, iy);	
		cursor.mx = mapCoord.mx;
		cursor.my = mapCoord.my;
		cursor.vix = ix;
		cursor.viy = iy;
		if (!mousedown) 
			return;
		updateTarget(e);
	}, false);
		
	return {	
		start: function() {					
			init();						
		},		
		
		changeCentered: function(value) {
			$.GIsoGame.Configuration.centered = value;
		},
		
		changeOutlines: function(value) {
			$.GIsoGame.Configuration.outlines = value;
		},
		
		changeNavigation: function(value) {
			$.GIsoGame.Configuration.directWalking = value;
		},
	};

})();

$.GIsoGame.Game.start();</script>