[HTML]<head>
	<script type="text/javascript" src="./SpriteLoader.js"></script>
	<script type="text/javascript" src="./LevelLoader.js"></script>
	<script type="text/javascript" src="./GFXUtils.js"></script>
	<script type="text/javascript" src="./Minimap.js"></script>
	<script type="text/javascript" src="./IsoRenderer.js"></script>	
	<script type="text/javascript" src="./Configuration.js"></script>		
</head>
<div style="margin: 10px 0;">
	<canvas id="canvasT" style="width: 100%;" height="600"></canvas>
</div>[/HTML]
<script>
var $ = $ || {};
$.GIsoGame = $.GIsoGame || {};
$.GIsoGame.Editor = (function() {

	let canvas = document.getElementById("canvasT");
	let ctx = canvas.getContext("2d");
	let width;
	let height;
	let halfWidth;
	let halfHeight;
	
	let spriteLoader;
	let levelLoader;
	let currentLevel;
	let isoRenderer;
	
	let lastTime = 0;
	
	let viewX = 0;
	let viewY = 0;
	
	let cellW = 64;
	let cellH = 32;	
	
	let menuMargin = 10;
	let menuBorder = 2;
	let menuItemBorder = 10;
	
	let spritesMenu = {
		dragTargetId: 2,
		x: 0,
		y: 0,
		width: 0,
		height: 100,
		itemWidth: 64,
		dragOffset: 0,
	};
	
	let brush = {
		size: 1,
		fill: 0,
	};
	
	let mergeMatrix;
	
	let fills = [];

	let lastPaintedX = -1;
	let lastPaintedY = -1;
	
	let level;
	
	// T/F dle tlačítka myši
	let mouseButtons = [];
	
	// na které části UI je prováděn mouse-drag
	let dragTargetId = -1;
		
	let cursor = {
		lastSx: 0,
		lastSy: 0,
		sx: 0,
		sy: 0,
		mx: 0, 
		my: 0,
		vix: 0,
		viy: 0,		
	};		

	/*
	* DRAWING
	*/	
	
	let draw = function(timestamp) {
		drawScene(timestamp);
		window.requestAnimationFrame(draw);
	};
	
	let drawSpritesMenu = function() {		
		let texDetailFunc = function(i) {
			return {
				tex: spriteLoader.getTexture(0, i),
				col: 0,
				row: 0
			};
		};
		let chooseItemFunc = function(id) {
			choosenTextureSprite = id;
		};
		drawItemsMenu(spritesMenu, spriteLoader.getGroupSize(0), texDetailFunc, chooseItemFunc);
	};
	
	let drawItemsMenu = function(menu, itemsCount, texDetailFunc, chooseItemFunc) {		
		ctx.fillStyle = "#333";		
		ctx.fillRect(menu.x, menu.y, menu.width, menu.height);
		
		// zmenšení aktivní plochy menu, aby se v ní dalo pracovat s položkami
		let fromX = menu.x + menuBorder;
		let toX = menu.x + menu.width - menuBorder;
		let fromY = menu.y + menuBorder;
		let toY = menu.y + menu.height - menuBorder;
		
		ctx.fillStyle = "#222";		
		ctx.fillRect(fromX, fromY, toX - fromX, toY - fromY);
		
		let itemWidth = menu.itemWidth + menuItemBorder * 2;
		let itemsStartX = Math.floor(width / 2 - itemWidth / 2);
		
		ctx.fillStyle = "#333";		
		ctx.fillRect(itemsStartX, fromY, itemWidth, toY - fromY);
		
		if (mouseButtons[0] && dragTargetId == menu.dragTargetId) {
			let diff = cursor.sx - itemsStartX;
			menu.dragOffset -= Math.floor(diff / itemWidth) * itemWidth;
			mouseButtons[0] = false;
		}
		
		let choosenItemId = Math.floor(-menu.dragOffset / itemWidth);
		if (choosenItemId < 0) {
			menu.dragOffset += itemWidth * choosenItemId;
			choosenItemId = 0;			
		} else if (choosenItemId >= itemsCount) {
			menu.dragOffset += itemWidth * (choosenItemId - itemsCount);
			choosenItemId = itemsCount - 1;
		}
		chooseItemFunc(choosenItemId);
		
		for (let i = 0; i < itemsCount; i++) {	
			let texDetail = texDetailFunc(i);			
			let x = itemsStartX + menuItemBorder + (i - choosenItemId) * itemWidth;			
			let leftOverlap = fromX - x;
			let rightOverlap = x + texDetail.tex.width - toX;
			let itemsStartY = Math.floor(fromY + menu.height / 2 - menuBorder - texDetail.tex.height / 2);
			if ((leftOverlap < 0 || rightOverlap < 0) && leftOverlap < texDetail.tex.width && rightOverlap < texDetail.tex.width) {
				let leftTrim = leftOverlap > 0 ? leftOverlap : 0;
				let rightTrim = rightOverlap > 0 ? rightOverlap : 0;
				let trimWidth = texDetail.tex.width - leftTrim - rightTrim;
				ctx.drawImage(texDetail.tex.canvas, 
					texDetail.col * texDetail.tex.width + leftTrim, texDetail.row * texDetail.tex.height, trimWidth, texDetail.tex.height, 
					x + leftTrim, itemsStartY, trimWidth, texDetail.tex.height);	
			}
		}
	};
	
	let getTypeByTile = function(spriteId, tileId) {
		let tiles = fills[spriteId].tiles;
		for (let type = 0; type < tiles.length; type++)
			if (tileId >= tiles[type][0] && tileId < tiles[type][1])
				return type;
		return -1;
	};
						
	let placeRandomTile = function(index, type, spriteId) {
		let fill = fills[spriteId];
		let range = fill.tiles[type];	
		let tileId = range[0] + Math.floor(Math.random() * (range[1] - range[0]));
		let existing = level.grounds[index];
		if (existing == undefined || existing.length == 0) {
			level.grounds[index] = [spriteId, tileId]; // prázdné
		} else {
			let existingSpriteId = existing[0];
			let existingType = getTypeByTile(existingSpriteId, existing[1]);
			if (existing[0] == spriteId) { // obsazené stejným spritem
				level.grounds[index] = [spriteId, mergeMatrix[existingType, type]]; // prázdné
			}
		}
	};
			
	let paint = function(mx, my) {		
		let fromX = mx - brush.size;
		let toX = mx + brush.size;
		let fromY = my - brush.size;
		let toY = my + brush.size;
		for (let tx = fromX; tx <= toX; tx++) {
			if (tx >= level.mapW || tx < 0) continue;
			for (let ty = fromY; ty <= toY; ty++) {
				if (ty >= level.mapH || ty < 0) continue;
				let index = tx + ty * level.mapW;
				let type;
				if (tx == fromX && ty == fromY) type = 0; // levý horní roh
				else if (tx == fromX && ty == toY) type = 6; // levý dolní roh
				else if (tx == toX && ty == fromY) type = 2; // pravý horní roh
				else if (tx == toX && ty == toY) type = 8; // pravý dolní roh
				else if (tx == fromX) type = 3; // levá strana
				else if (tx == toX) type = 5; // pravá strana
				else if (ty == fromY) type = 1; // horní strana
				else if (ty == toY) type = 7; // dolní strana
				else type = 4; // prostředek					
				placeRandomTile(index, type, brush.fill);
			}
		}					
	};
			
	let drawScene = function(timestamp) {	
		if (!spriteLoader.isLoaded())
			return;
			
		// Update času pro animace
		let delay = timestamp - lastTime;
		lastTime = timestamp;	
				
		isoRenderer.update(delay, viewX, viewY);
		
		drawSpritesMenu();

		$.GIsoGame.Minimap.drawMinimap(ctx, currentLevel);
		
		if (cursor.mx < level.mapW && cursor.mx >= 0 && cursor.my < level.mapH && cursor.my >= 0
			&& (mouseButtons[0] || mouseButtons[2])) {			
			let paintedX = Math.floor(cursor.mx); 
			let paintedY = Math.floor(cursor.my);
			if (paintedX != lastPaintedX || paintedY != lastPaintedY) {
				paint(paintedX, paintedY);
				lastPaintedX = paintedX;		
				lastPaintedY = paintedY;
			}
		}		
	};		
	
	/*
	* CONTROLS
	*/
	
	let dragMove = function() {
		let diffX = cursor.sx - cursor.lastSx;
		let diffY = cursor.sy - cursor.lastSy;
		switch (dragTargetId) {
		case 0:
			viewX += diffX;
			viewY += diffY;
			break;
		case 1:
			tilesMenu.dragOffset += diffX;
			break;
		case 2:
			spritesMenu.dragOffset += diffX;
			break;		
		} 
	};
	
	let mouseButtonChange = function(down, button) {
		mouseButtons[button] = down;		
		if (down) {
			if (cursor.sx > spritesMenu.x && cursor.sx < spritesMenu.x + spritesMenu.width 
				&& cursor.sy > spritesMenu.y && cursor.sy < spritesMenu.y + spritesMenu.height) {				
				dragTargetId = 2; // sprites menu 
			} else {
				dragTargetId = 0; // plocha
			}
		} else {
			if (button == 0) {
				// aby šlo to samé pole překreslit když na něj kliknu (ne držení)
				lastPaintedX = -1;
				lastPaintedY = -1;
			}
		}
	};
	
	canvas.addEventListener('contextmenu', function(e) {
		// Block right-click menu thru preventing default action.
		if (e.button == 2) 
		  e.preventDefault();		
	 });
	
	canvas.addEventListener("mousedown", function (e) {
		mouseButtonChange(true, e.button);
	}, false);
 
	canvas.addEventListener("mouseup", function (e) {
		mouseButtonChange(false, e.button);
	}, false);
	
	canvas.addEventListener("mouseleave", function (e) {
		mouseButtonChange(false, 0);
		mouseButtonChange(false, 1);
		mouseButtonChange(false, 2);
	}, false);
	
	canvas.addEventListener("mousemove", function (e) {
		let bound = canvas.getBoundingClientRect();
		cursor.lastSx = cursor.sx;
		cursor.lastSy = cursor.sy;
		cursor.sx = e.clientX - bound.x;
		cursor.sy = e.clientY - bound.y;
		let ix = cursor.sx - viewX;
		let iy = cursor.sy - viewY;
		mapCoord = isoRenderer.toMap(ix, iy);	
		cursor.mx = mapCoord.mx;
		cursor.my = mapCoord.my;
		cursor.vix = ix;
		cursor.viy = iy;
		if (mouseButtons[1])
			dragMove();
	}, false);

	/*
	* INIT
	*/
	
	let initMergeMatrix = function() {
		let TL=0,T=1,TR=2,L=3,M=4,R=5,BL=6,B=7,BR=8,OTL=9,OTR=10,OBL=11,OBR=12;
		let E=-1; // nedefinováno
		mergeMatrix = [
			//  TL   T  TR   L   M   R  BL   B  BR OTL OTR OBL OBR
			[   TL,  T,  T,  L,  M,  M,  L,OTR,  E,  M,  M,  M,OBR], // TL
			[     ,  T,  T,OBR,  M,OBL,OBR,  M,OBL,  M,  M,OBL,OBR], // T
			[     ,   , TR,OBR,  M,  R,  E,  M,  R,OTL,  M,OBL,OBR], // TR
			[     ,   ,   ,  L,  M,  M,  L,OTR,OTR,  M,OTR,  M,OBR], // L
			[     ,   ,   ,   ,  M,  M,  M,  M,  M,  M,  M,  M,  M], // M
			[     ,   ,   ,   ,   ,  R,  M,OTL,  R,OTL,  M,OBL,  M], // R
			[     ,   ,   ,   ,   ,   , BL,  B,  B,OTL,OTR,  M,OBR], // BL
			[     ,   ,   ,   ,   ,   ,   ,  B,  B,OTL,OTR,  M,  M], // B
			[     ,   ,   ,   ,   ,   ,   ,   , BR,OTL,OTR,  M,  M], // BR			
			[     ,   ,   ,   ,   ,   ,   ,   ,   ,OTL,  M,  M,  M], // OTL
			[     ,   ,   ,   ,   ,   ,   ,   ,   ,   ,OTR,  M,  M], // OTR
			[     ,   ,   ,   ,   ,   ,   ,   ,   ,   ,   ,OBL,  M], // OBL
			[     ,   ,   ,   ,   ,   ,   ,   ,   ,   ,   ,   ,OBR], // OBR
		];
		for (let i = 0; i < mergeMatrix.length; i++)
			for (let j = 0; j < mergeMatrix.length; j++)
				mergeMatrix[j][i] = mergeMatrix[i][j];
	};
	
	let addFill = function(group, spriteId, middle, right, bottom, top, left, 
			innerTopRight, innerBottomRight, innerTopLeft, innerBottomLeft,
			outerTopRight, outerBottomRight, outerTopLeft, outerBottomLeft) {
		fills.push({
			group: group,
			spriteId: spriteId,
			tiles: [outerTopLeft, top, outerTopRight, 
					left, middle, right,
					outerBottomLeft, bottom, outerBottomRight,
					innerTopLeft, innerTopRight,
					innerBottomLeft, innerBottomRight]			
		});
	};
	
	let init = function() {	
		canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
		
		$.GIsoGame.Configuration.outlines = true;
			
		width = canvas.width;
		height = canvas.height;	
		halfWidth = width / 2;
		halfHeight = height / 2;
				
		spritesMenu.x = menuMargin;
		spritesMenu.width = width - menuMargin * 2;
		spritesMenu.y = height - menuMargin - spritesMenu.height;	
		
		canvas.style.position = "absolute";
		canvas.style.left = "0";
		canvas.style.top = "0";
		canvas.style.zIndex = "999";				
				
		level = {
			mapW: 10,
			mapH: 10,
			grounds:[],
			objects: [],
			walls: []
		}
	
		currentLevel = $.GIsoGame.LevelLoader.createLevel(level);
				
		initMergeMatrix();
				
		spriteLoader = $.GIsoGame.SpriteLoader.create();
		
		let materials = ["grass_medium_64x32.png", "stone_path_64x32.png", "grass_dry_64x32.png"];
		for (let i = 0; i < materials.length; i++) {
			spriteLoader.queueTexture(0, "https://www.gattserver.cz/fm-files/isometric-files/ground/" + materials[i], 8, 7, cellW, cellH, 0, 0);
			addFill(0, i, [0, 20], 			
				[20, 24], [24, 28], [28, 32], [32, 36],
				[36, 38], [38, 40], [40, 42], [42, 44],
				[44, 46], [46, 48], [48, 50], [50, 52]
			);
		}
		
		spriteLoader.queueTexture(2, "https://www.gattserver.cz/fm-files/isometric-files/plants/weed03.png", 1, 1, 128, 64, 0, 16);
		spriteLoader.queueTexture(2, "https://www.gattserver.cz/fm-files/isometric-files/plants/swirl02.png", 1, 1, 128, 64, 0, 16);
		spriteLoader.queueTexture(3, "https://www.gattserver.cz/fm-files/isometric-files/walls/iso_dungeon_walls_by_pfunked.png", 8, 4, 128, 128, 32, 64 + 16);
		spriteLoader.queueTexture(3, "https://www.gattserver.cz/fm-files/isometric-files/plants/pine-none03.png", 1, 1, 256, 256, 64 + 42, 128 + 64);
		spriteLoader.queueTexture(3, "https://www.gattserver.cz/fm-files/isometric-files/walls/barricade_tiles.png", 4, 3, 128, 128, 32, 64 + 16);
		
		spriteLoader.load();
					
		isoRenderer = $.GIsoGame.IsoRenderer.create(ctx, width, height, cellW, cellH, currentLevel, spriteLoader, cursor);		
		
		let iso = isoRenderer.toIso(level.mapW / 2, level.mapH / 2);
		viewX = halfWidth - iso.ix;
		viewY = (height - spritesMenu.height - menuMargin * 2) / 2 - iso.iy;
								
		// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas
		// https://www.html5rocks.com/en/tutorials/canvas/performance/#toc-ref
		// https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
		// https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame
		window.requestAnimationFrame(draw);		
	};		
		
	return {	
		start: function() {					
			init();						
		},	
	};

})();

$.GIsoGame.Editor.start();</script>