<head>	
	<script type="text/javascript" src="../libs/colors.js"></script>
</head>

<div style="margin: 10px 0;">
	<canvas id="canvas" width="700" height="400"></canvas>
</div>
<script>var $ = $ || {};
$.perlin = (function() {

	let canvas = document.getElementById("canvas");
	let ctx = canvas.getContext("2d");
	let width;
	let height;
	let halfWidth;
	let halfHeight;
			
	let fillSegment = function(tree) {		
		let color = getColorByLevel(tree.level);
		ctx.fillStyle = color;
		ctx.strokeStyle = "black";
		let x = tree.x - tree.w / 2;
		let y = tree.y - tree.h / 2;		
		ctx.fillRect(x, y, tree.w, tree.h);
		ctx.strokeRect(x, y, tree.w, tree.h);		
	};
	
	let init = function() {	
		width = canvas.width;
		height = canvas.height;
		halfWidth = width / 2; 
		halfHeight = height / 2;
		
		let grid = [];
		let cellPxSize = 50;
		let cellHalfPxSize = cellPxSize / 2;
		let gridCols = width / cellPxSize;
		let gridRows = height / cellPxSize;		
		let distanceMax = Math.sqrt(2) * cellPxSize / 2;
	
		ctx.clearRect(0, 0, width, height);
		
		ctx.lineWidth = 1;
		ctx.strokeStyle = "blue";
		ctx.strokeRect(0, 0, width, height);

		for (let row = 0; row <= gridRows; row++) {
			grid[row] = [];
			for (let col = 0; col <= gridCols; col++) {
				let radians = Math.random() * Math.PI * 2;
				let xk = distanceMax * Math.cos(radians);
				let yk = distanceMax * Math.sin(radians);
				grid[row][col] = [xk, yk];
				
				// vektor udává lineární funkci 
				// F1: y = a * x + b
				// a = y / x
				// b = 0, protože je vždy v počátku
				let a = yk / xk;	
				let b = 0;

				// F1 a F2 jsou paralelní funkce a mají tak společnou kolmici 
				// Fk: y = ak * x + bk
				// bk je 0, protože kolmice prochází počátkem
				let ak = -1 / a;
				let bk = 0;

				for (let yp = -cellHalfPxSize; yp < cellHalfPxSize ; yp++) {			
					for (let xp = -cellHalfPxSize; xp < cellHalfPxSize; xp++) {												
						// zkoumaný bod určuje paralelní lineární funkci 
						// F2: y = a * x + b + c		
						let c = yp - a * xp;
						// bodem [xp, yp] prochází F2, ale ne Fk
						// bodem [xq, yq] prochází F2 a i Fk
						let xq = (b - bk + c) / (ak - a);
						let yq = a * xq + b + c;	
						// vzdálenost bodu od kolmice
						let diffX = xq - xp;
						let diffY = yq - yp;
						let dist = Math.sign(diffX) * Math.sqrt(diffX * diffX + diffY * diffY) / distanceMax;
						let scaledDist = Math.max(-1, Math.min(1, dist));
						let lightnessScaled = 1 - Math.abs(scaledDist);
										
						//ctx.fillStyle = (cellX + cellY) % 2 == 0 ? "white" : "lightgrey";
						ctx.fillStyle = $.GJSLibColors.hslToRGB(scaledDist > 0 ? 0.7 : 0.5, 0.8, lightnessScaled);
						ctx.fillRect(xp + cellPxSize * col, yp + cellPxSize * row, 1, 1);
					}
				}
			}
		}
										
		for (let y = 0; y <= gridRows; y++) {
			let cy = y * cellPxSize;
			ctx.strokeStyle = "blue";
			ctx.beginPath();
			ctx.moveTo(0, cy);
			ctx.lineTo(width, cy);
			ctx.stroke();	
			for (let x = 0; x <= gridCols; x++) {
				let cx = x * cellPxSize;
				if (y == 0) {
					ctx.strokeStyle = "blue";
					ctx.beginPath();
					ctx.moveTo(cx, 0);
					ctx.lineTo(cx, height);
					ctx.stroke();
				}				
				ctx.lineWidth = 2;
				ctx.strokeStyle = "red";
				ctx.beginPath();
				ctx.moveTo(cx, cy);
				ctx.lineTo(cx + grid[y][x][0], cy + grid[y][x][1]);
				ctx.stroke();
				ctx.lineWidth = 1;
			}
		}	

	};	
		
	return {

		start: function() {	
			init();			
		},
		
	};

})();

$.perlin.start();</script>