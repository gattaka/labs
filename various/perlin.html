<head>	
	<script type="text/javascript" src="../libs/colors.js"></script>
</head>
[N1]Demo[/N1]
[HTML]<div>
	<table>
		<tbody>
			<tr>
				<td>Gravity <0-0.1></td>
				<td>Balls count <1-300></td>
				<td>Blast power <1-100></td>
				<td></td>
			</tr>
			<tr>
				<td><input id="gravityInput" style="width: 80px;" value="0.002"></td>
				<td><input id="ballsInput" style="width: 80px;" value="200"></td>
				<td><input id="blastInput" style="width: 80px;" value="15"></td>
				<td><input id="drawInput" type="checkbox" onclick="$.gravity.draw(this.checked)" >Draw?</input></td>
				<td><input id="outlinesInput" type="checkbox" onclick="$.gravity.outline(this.checked)" checked>Outlines?</input></td>
				<td><button type="button" onclick="$.perlin.start()">Run!</button></td>
			</tr>
		</tbody>
	</table>
</div>
<div style="margin: 10px 0;">
	<canvas id="canvas" width="700" height="600"></canvas>
</div>[/HTML]
<script>var $ = $ || {};
$.perlin = (function() {

	let canvas = document.getElementById("canvas");
	let ctx = canvas.getContext("2d");
	let width = canvas.width;
	let height = canvas.height;
	let halfWidth = width / 2; 
	let halfHeight = height / 2;
	
	let cellPxSize;
	let pointSize;
	let showCells;
	let showVectors;
	let smooth;
	
	let lightMultiplier;
	let colorMultiplier;
	let minAngleStep;
	let maxAngleStep;
	let minLengthStep;
	let maxLengthStep;
	let colorStep;
			
	let colorOffset;
	let grid;
	let changeGrid;
	let cellHalfPxSize;
	let gridCols;
	let gridRows;
	
	let interval = 50;
	let innerIntervalCallback;
	
	// Fade function as defined by Ken Perlin. This eases coordinate values
	// so that they will ease towards integral values. This ends up smoothing
	// the final output.
	// 6t^5 - 15t^4 + 10t^3
	let fade = function(t) {
		return t * t * t * (t * (t * 6 - 15) + 10);         
	};
	
	let lerp = function(a, b, x) {
		return a + x * (b - a);
	};
	
	let draw = function() {
		ctx.clearRect(0, 0, width, height);		

		for (let x = 0; x < width; x += pointSize) {
			for (let y = 0; y < height; y += pointSize) {	
				// souřadnice bodu vzhledem ke počátku buňky, v rozsahu 0-1
				let cx = (x % cellPxSize) / cellPxSize;			
				let cy = (y % cellPxSize) / cellPxSize;
				
				let x0 = Math.floor(x / cellPxSize); 
				let x1 = x0 + 1;
				let y0 = Math.floor(y / cellPxSize); 
				let y1 = y0 + 1;
				
				let grad00 = grid[x0][y0];	
				let grad01 = grid[x0][y1];
				let grad10 = grid[x1][y0];
				let grad11 = grid[x1][y1];			
				
				let dist00 = {x: cx, y: cy};
				let dist01 = {x: cx, y: cy - 1};
				let dist10 = {x: cx - 1, y: cy};
				let dist11 = {x: cx - 1, y: cy - 1};
				
				let dot00 = grad00.x * dist00.x + grad00.y * dist00.y;
				let dot01 = grad01.x * dist01.x + grad01.y * dist01.y;
				let dot10 = grad10.x * dist10.x + grad10.y * dist10.y;
				let dot11 = grad11.x * dist11.x + grad11.y * dist11.y;
				
				let u = smooth ? fade(cx) : cx;
				let v = smooth ? fade(cy) : cy;
				
				// Je potřeba, aby se interpolace prováděla na ose, 
				// na které dochází ke změně -- drobná chyba způsobí
				// že se vykreslí naprosto nepoužitelné vzory
				let v1 = lerp(dot00, dot10, u);
				let v2 = lerp(dot01, dot11, u);
				let average = lerp(v1, v2, v);		
				let result = average;
						
				let lightness = Math.min(1, Math.max(0, (lightMultiplier * result + 1) / 2));
				let color = ((colorMultiplier * result + 1) / 2 + colorOffset) % 1;										
				
				ctx.fillStyle = $.GJSLibColors.hslToRGB(color, 0.8, lightness);
				ctx.fillRect(x, y, pointSize, pointSize);
			}
		}
			
		for (let x = 0; x <= gridCols; x++) {
			let cx = x * cellPxSize;
			if (showCells) {
				ctx.strokeStyle = "blue";
				ctx.beginPath();
				ctx.moveTo(cx, 0);
				ctx.lineTo(cx, height);
				ctx.stroke();
			}

			for (let y = 0; y <= gridRows; y++) {
				let cy = y * cellPxSize;

				if (x == 0 && showCells) {
					ctx.strokeStyle = "blue";
					ctx.beginPath();
					ctx.moveTo(0, cy);
					ctx.lineTo(width, cy);
					ctx.stroke();	
				}				

				if (showVectors) {
					ctx.strokeStyle = "black";
					ctx.beginPath();
					ctx.moveTo(cx, cy);
					ctx.lineTo(cx + grid[x][y].x * cellPxSize, cy + grid[x][y].y * cellPxSize);
					ctx.stroke();
				}
			}
		}
	};
	
	let step = function() {
		for (let col = 0; col <= gridCols; col++) {			
			for (let row = 0; row <= gridRows; row++) {				
				grid[col][row].angle = (grid[col][row].angle + changeGrid[col][row].angleStep) % 360;
				let newLen = grid[col][row].length + changeGrid[col][row].lengthStep;
				if (newLen > 1 || newLen < 0) {
					changeGrid[col][row].lengthStep *= -1;
					newLen += changeGrid[col][row].lengthStep;
				}
				grid[col][row].length = newLen
				let radians = grid[col][row].angle / 180 * Math.PI;
				grid[col][row].x = Math.cos(radians) * grid[col][row].length; 
				grid[col][row].y = Math.sin(radians) * grid[col][row].length;				
			}
		}	
		
		colorOffset = (colorOffset + colorStep) % 1;
	
		draw();
	};
	
	let innnerChangeInterval = function(value) {
		if (isNaN(value))
			return;
		let newValue = Number(value);
		if (newValue < 1)
			return;
		console.log("interval changed from '" + interval + "' to '" + newValue + "'");
		interval = newValue;
		
		if (innerIntervalCallback) 
			clearInterval(innerIntervalCallback);
		
		innerIntervalCallback = setInterval(function() {
			step();
		}, interval);
	};
	
	let init = function() {	

		ctx.lineWidth = 1;		
		
		cellPxSize = 80;
		pointSize = 5;	
		showCells = false;
		showVectors = false;
		smooth = true;
				
		lightMultiplier = 1.5;
		colorMultiplier = 2;
		colorStep = 0.01;
		minAngleStep = 0.2;
		maxAngleStep = 10;
		minLengthStep = 0.01;
		maxLengthStep = 0.1;
		
		colorOffset = 0;
		grid = [];
		changeGrid = [];
		cellHalfPxSize = cellPxSize / 2;
		gridCols = Math.ceil(width / cellPxSize);
		gridRows = Math.ceil(height / cellPxSize);	

		// generování gradient vektorů
		for (let col = 0; col <= gridCols; col++) {			
			grid[col] = [];
			changeGrid[col] = [];
			for (let row = 0; row <= gridRows; row++) {
				grid[col][row] = {
					angle: Math.random() * 360,
					length: 1
				};
				changeGrid[col][row] = {
					angleStep: Math.random() * (maxAngleStep - minAngleStep) + minAngleStep,
					lengthStep: Math.random() * (minLengthStep - maxLengthStep) + minLengthStep
				};
			}
		}				
		
		innnerChangeInterval(interval);	
		
	};	
		
	return {

		start: function() {	
			init();			
		},
		
	};

})();

$.perlin.start();</script>