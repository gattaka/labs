<head>	
	<script type="text/javascript" src="../libs/colors.js"></script>
</head>

<div style="margin: 10px 0;">
	<canvas id="canvas" width="700" height="600"></canvas>
</div>
<script>var $ = $ || {};
$.perlin = (function() {

	let canvas = document.getElementById("canvas");
	let ctx = canvas.getContext("2d");
	let width;
	let height;
	let halfWidth;
	let halfHeight;
	
	// Fade function as defined by Ken Perlin. This eases coordinate values
	// so that they will ease towards integral values. This ends up smoothing
	// the final output.
	// 6t^5 - 15t^4 + 10t^3
	let fade = function(t) {
		return t * t * t * (t * (t * 6 - 15) + 10);         
	};
	
	let lerp = function(a, b, x) {
		return a + x * (b - a);
	};
	
	let init = function() {	
		width = canvas.width;
		height = canvas.height;
		halfWidth = width / 2; 
		halfHeight = height / 2;
		
		let cellPxSize = 60;
		let pointSize = 5;
		let gradientSize = 0.75;
		let showCells = false;
		let showVectors = false;
		let smooth = true;
		let colorOffset = 0.2;
		
		let grid = [];
		let cellHalfPxSize = cellPxSize / 2;
		let gridCols = Math.ceil(width / cellPxSize);
		let gridRows = Math.ceil(height / cellPxSize);		
	
		ctx.clearRect(0, 0, width, height);
		
		ctx.lineWidth = 1;
		ctx.strokeStyle = "blue";
		ctx.strokeRect(0, 0, width, height);

		let buffer = [];

		// generování gradient vektorů
		for (let col = 0; col <= gridCols; col++) {			
			grid[col] = [];
			for (let row = 0; row <= gridRows; row++) {
				let xk;				
				let yk;				
				//xk = Math.random() > 0.5 ? -1 : 1;
				//yk = Math.random() > 0.5 ? -1 : 1;			
				let radians = Math.random() * Math.PI * 2;
				xk = Math.cos(radians);
				yk = Math.sin(radians);
				grid[col][row] = {
					x: xk, 
					y: yk
				};
			}
		}
		
		for (let x = 0; x < width; x += pointSize) {
			for (let y = 0; y < height; y += pointSize) {	
				// souřadnice bodu vzhledem ke počátku buňky, v rozsahu 0-1
				let cx = (x % cellPxSize) / cellPxSize;			
				let cy = (y % cellPxSize) / cellPxSize;
				
				let x0 = Math.floor(x / cellPxSize); 
				let x1 = x0 + 1;
				let y0 = Math.floor(y / cellPxSize); 
				let y1 = y0 + 1;
				
				let grad00 = grid[x0][y0];	
				let grad01 = grid[x0][y1];
				let grad10 = grid[x1][y0];
				let grad11 = grid[x1][y1];			
				
				let dist00 = {x: cx, y: cy};
				let dist01 = {x: cx, y: cy - 1};
				let dist10 = {x: cx - 1, y: cy};
				let dist11 = {x: cx - 1, y: cy - 1};
				
				let dot00 = grad00.x * dist00.x + grad00.y * dist00.y;
				let dot01 = grad01.x * dist01.x + grad01.y * dist01.y;
				let dot10 = grad10.x * dist10.x + grad10.y * dist10.y;
				let dot11 = grad11.x * dist11.x + grad11.y * dist11.y;
				
				let u = smooth ? fade(cx) : cx;
				let v = smooth ? fade(cy) : cy;
				
				// Je potřeba, aby se interpolace prováděla na ose, 
				// na které dochází ke změně -- drobná chyba způsobí
				// že se vykreslí naprosto nepoužitelné vzory
				let v1 = lerp(dot00, dot10, u);
				let v2 = lerp(dot01, dot11, u);
				let average = lerp(v1, v2, v);		
				let result = average;
				
				buffer[width * y + x] = result;				
				let lightness = (result + 1) / 2;
				let color = ((result + 1) / 2 + colorOffset) % 1;
				
				ctx.fillStyle = $.GJSLibColors.hslToRGB(color, 1, lightness);
				ctx.fillRect(x, y, pointSize, pointSize);
			}
		}
			
		ctx.lineWidth = 1;
		for (let x = 0; x <= gridCols; x++) {
			let cx = x * cellPxSize;
			if (showCells) {
				ctx.strokeStyle = "blue";
				ctx.beginPath();
				ctx.moveTo(cx, 0);
				ctx.lineTo(cx, height);
				ctx.stroke();
			}

			for (let y = 0; y <= gridRows; y++) {
				let cy = y * cellPxSize;

				if (x == 0 && showCells) {
					ctx.strokeStyle = "blue";
					ctx.beginPath();
					ctx.moveTo(0, cy);
					ctx.lineTo(width, cy);
					ctx.stroke();	
				}				

				if (showVectors) {
					ctx.strokeStyle = "black";
					ctx.beginPath();
					ctx.moveTo(cx, cy);
					ctx.lineTo(cx + grid[x][y].x * cellPxSize, cy + grid[x][y].y * cellPxSize);
					ctx.stroke();
				}
			}
		}	
		
	};	
		
	return {

		start: function() {	
			init();			
		},
		
	};

})();

$.perlin.start();</script>