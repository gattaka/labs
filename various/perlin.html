<head>	
	<script type="text/javascript" src="../libs/colors.js"></script>
</head>

<div style="margin: 10px 0;">
	<canvas id="canvas" width="700" height="400"></canvas>
</div>
<script>var $ = $ || {};
$.perlin = (function() {

	let canvas = document.getElementById("canvas");
	let ctx = canvas.getContext("2d");
	let width;
	let height;
	let halfWidth;
	let halfHeight;
	
	let grid;
	let gridSize;
	let vectorMax;
	let cellWidth;
	let cellHeight;
		
	let fillSegment = function(tree) {		
		let color = getColorByLevel(tree.level);
		ctx.fillStyle = color;
		ctx.strokeStyle = "black";
		let x = tree.x - tree.w / 2;
		let y = tree.y - tree.h / 2;		
		ctx.fillRect(x, y, tree.w, tree.h);
		ctx.strokeRect(x, y, tree.w, tree.h);		
	};
	
	let init = function() {	
		width = canvas.width;
		height = canvas.height;
		halfWidth = width / 2; 
		halfHeight = height / 2;
		
		grid = [];
		cellPxSize = 50;
		gridCols = width / cellPxSize;
		gridRows = height / cellPxSize;		
		// maximální X nebo Y délky vektoru (ne diagonála)
		vectorMax = cellPxSize / 2;
		distanceMax = Math.sqrt(2) * cellPxSize;
	
		ctx.clearRect(0, 0, width, height);
		
		ctx.lineWidth = 1;
		ctx.strokeStyle = "blue";
		ctx.strokeRect(0, 0, width, height);

		for (let y = 0; y <= gridRows; y++) {
			let row = [];
			grid[y] = row;
			for (let x = 0; x <= gridCols; x++) {
				let cx = x * cellPxSize;
				let lx = vectorMax;// * (Math.random() * 2 - 1);
				let ly = vectorMax;// * (Math.random() * 2 - 1);
				row[x] = [lx, ly];
			}
		}
				
		for (let y = 0; y < height; y++) {			
			for (let x = 0; x < width; x++) {
				let cellX = Math.round(x / cellPxSize);
				let cellY = Math.round(y / cellPxSize);
				// vektor jde od počátku buňky do [xk, yk]
				let vector = grid[cellY][cellX];
				let xk = vector[0];
				let yk = vector[0];
				// vnitřní souřadnice bodu vzhledem k centru buňky [xp, yp]
				let xp = cellX * cellPxSize - x;
				let yp = cellY * cellPxSize - y;
				
				// vektor udává lineární funkci 
				// F1: y = a * x + b
				// a = y / x
				// b = 0, protože je vždy v počátku
				let a = yk / xk;	
				let b = 0;
				// zkoumaný bod určuje paralelní lineární funkci 
				// F2: y = a * x + b + c		
				let c = yp - a * xp;
				// F1 a F2 jsou paralelní funkce a mají tak společnou kolmici 
				// Fk: y = ak * x + bk
				let ak = -1 / a;
				let bk = xk * (a + 1/a) + b;
				// bodem [xk, yk] prochází F1 a Fk
				// bodem [xp, yp] prochází F2, ale ne Fk
				// bodem [xq, yq] prochází F2 a i Fk
				let xq = (b - bk + c) / (ak - a);
				let yq = a * xq + b + c;	
				// vzdálenost bodu od kolmice
				let dist = Math.sqrt(Math.pow(xq - xp, 2) + Math.pow(yq - yp, 2));				
			
				//ctx.fillStyle = (cellX + cellY) % 2 == 0 ? "white" : "lightgrey";
				ctx.fillStyle = $.GJSLibColors.hslToRGB(0.5, dist / distanceMax, 0.4);
				ctx.fillRect(x, y, 1, 1);
			}
		}
				
		for (let y = 0; y <= gridRows; y++) {
			let cy = y * cellPxSize;
			ctx.strokeStyle = "blue";
			ctx.beginPath();
			ctx.moveTo(0, cy);
			ctx.lineTo(width, cy);
			ctx.stroke();	
			for (let x = 0; x <= gridCols; x++) {
				let cx = x * cellPxSize;
				if (y == 0) {
					ctx.strokeStyle = "blue";
					ctx.beginPath();
					ctx.moveTo(cx, 0);
					ctx.lineTo(cx, height);
					ctx.stroke();
				}				
				ctx.lineWidth = 2;
				ctx.strokeStyle = "red";
				ctx.beginPath();
				ctx.moveTo(cx, cy);
				ctx.lineTo(cx + grid[y][x][0], cy + grid[y][x][1]);
				ctx.stroke();
				ctx.lineWidth = 1;
			}
		}	

	};	
		
	return {

		start: function() {	
			init();			
		},
		
	};

})();

$.perlin.start();</script>