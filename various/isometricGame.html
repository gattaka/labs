[HTML]<input type="checkbox" onchange="$.isometricGame.changeCentered(this.checked)" style="width: 80px;" checked>Centered?</input>
<input type="checkbox" onchange="$.isometricGame.changeOutlines(this.checked)" style="width: 80px;" checked>Outlines?</input>
<div style="margin: 10px 0;">
	<canvas id="canvasT" width="700" height="400"></canvas>
</div>[/HTML]
<script>var $ = $ || {};
$.isometricGame = (function() {

	let canvas = document.getElementById("canvasT");
	let ctx = canvas.getContext("2d");
	let width = canvas.width;
	let height = canvas.height;	
	let halfWidth = width / 2;
	let halfHeight = height / 2;
	
	let lastTime = 0;
	
	let centered = true;
	let outlines = true;
	
	let viewX = 0;
	let viewY = 0;
	
	let isoCenter;
	let cellW = 128;
	let cellH = 64;
	
	let loaded = false;
	let loadingProgress = 0;
	let textures = [];
	
	// mapa povrchů
	let map = [
		[0,0],[0,1],[0,4],[0,1],
		[0,3],[0,0,1,48],[0,1,1,45],[0,5],
		[0,0],[0,3,1,50],[0,5,1,47],[0,1],
		[0,3],[0,2],[0,3],[0,5],		
	];
	let objectMap = [
		[],[],[],[],
		[1,0],[],[0,0],[2,0],
		[],[],[],[],
		[],[],[],[],
	];
	let wallsMap = [
		[0,6],[0,8],[0,8],[0,3],
		[0,0],[],[],[],
		[],[],[],[],
		[],[0,1],[0,3],[],
	];
	let mapW = 4;
	let mapH = 4;
	
	let virtualTargetX = halfWidth;
	let virtualTargetY = halfHeight;
	
	// Stance (4 frames)
	// Walk (8 frames)
	// Attack (4 frames)
	// Cast (4 frames)
	// Block (2 frames)
	// Hit and Die (6 frames)
	// Aim Crossbow (4 frames)
	let heroSprite = {
		width: 128,
		height: 128,		
		directionFrames: 32,
		// počáteční frame animací
		loops: [0, 4, 8, 4, 4, 2, 6],
		// počty frame animací
		loopsFrames: [4, 8, 4, 4, 2, 6, 4],
		loopsMirror: [true, false, false, false, false, false, false],
		currentLoop: 0,
		// krok v rámci smyčky -- není to samé jako frame, protože
		// pokud jde o smyčku, která se zrcadlí, bude kroků 2x víc,
		// než má fyzicky smyčka snímků
		currentLoopStep: 0,
		// délka trvání frame
		delay: 100,
		// inkrement času
		timer: 0,
		// virtuální isometrické souřadnice
		// nejsou reálné, protože pokud bude postava uprostřed plochy,
		// nebudou se jeho reálné souřadnice měnit, ale je potřeba nějak
		// evidovat "posun" k cíli -- šlo by napevno postavu přilepit na
		// střed a posouvat jenom podklad, ale takhle je to obecnější a 
		// lze to jednoduše použít i na ostatní objekty/postavy, které 
		// nebudou ve středu, nebo pokud se postava na okraji mapy posune
		// mimo střed
		vix: virtualTargetX,
		viy: virtualTargetY,		
	};
	
	let hero = {
		mx: mapW / 2, 
		my: mapH / 2,
		speed: 0.1,	
		direction: 0
	};
		
	/*
	* COORD TRANSFORMATIONS
	*/
		
	let toIso = function(mx, my) {
		return {
			ix: halfWidth + mx * cellW / 2 + my * cellW / 2 - isoCenter.ix + viewX, 
			iy: halfHeight + my * cellH / 2 - mx * cellH / 2 - isoCenter.iy + viewY
		};
	};
	
	let toMap = function(ix, iy) {
		return {ix: halfWidth + mx, iy: halfHeight + my};
	};	
	
	/*
	* DRAWING
	*/
	
	let drawImg = function(groupId, spriteId, frame, ix, iy, showOutline) {
		let tex = textures[groupId][spriteId];
		let col = frame % tex.cols;
		let row = Math.floor(frame / tex.cols);
		let x = ix - tex.offsetX;
		let y = iy - tex.offsetY;
		ctx.drawImage(tex.canvas, 
			col * tex.width, row * tex.height, tex.width, tex.height, 
			x, y, tex.width, tex.height);
		if (showOutline) {
			ctx.strokeStyle = "black";
			ctx.lineWidth = 1;			
			ctx.strokeRect(x, y, tex.width, tex.height);
		}
	};		
	
	let drawPolygon = function(xArr, yArr) {		
		ctx.strokeStyle = "hsla(0,0%,0%,0.2)";
		ctx.lineWidth = 1;			
		for (let d = 0; d < 2; d++) {
			ctx.beginPath();
			for (let i = 0; i < xArr.length + 1; i++) {
				let ii = i % xArr.length;
				if (i == 0) 
					ctx.moveTo(xArr[ii], yArr[ii]);
				else 
					ctx.lineTo(xArr[ii], yArr[ii]);
			}
			ctx.stroke();
		}
	}
		
	let drawIsoCell = function(isoCell) {		
		let x = [isoCell.ix - cellW / 2, isoCell.ix, isoCell.ix + cellW / 2, isoCell.ix];
		let y = [isoCell.iy, isoCell.iy - cellH / 2, isoCell.iy, isoCell.iy + cellH / 2];		
		
		// Mimo view nemá cenu vykreslovat
		if (x[1] < 0 || x[3] > width || y[0] > height || y[2] < 0)
			return;
			
		drawImg(0, isoCell.value[0], isoCell.value[1], isoCell.ix - cellW / 2, isoCell.iy - cellH / 2, false);	

		// existuje přechod?
		if (isoCell.value.length > 2)
			drawImg(0, isoCell.value[2], isoCell.value[3], isoCell.ix - cellW / 2, isoCell.iy - cellH / 2, false);	
		
		if (outlines)
			drawPolygon([x[0], x[1], x[2], x[3]], [y[0], y[1], y[2], y[3]]);							
	};
		
	let draw = function(timestamp) {
		drawScene(timestamp);
		window.requestAnimationFrame(draw);
	};
			
	let drawScene = function(timestamp) {	
		if (!loaded)
			return;
			
		ctx.clearRect(0, 0, width, height);
		
		ctx.strokeStyle = "black";
		ctx.lineWidth = 1;					
		ctx.strokeRect(0, 0, width, height);
		
		ctx.beginPath();
		ctx.moveTo(halfWidth, 0);
		ctx.lineTo(halfWidth, height);
		ctx.stroke();
		
		ctx.beginPath();
		ctx.moveTo(0, halfHeight + 20);
		ctx.lineTo(width, halfHeight + 20);
		ctx.stroke();						

		// map se musí vykreslovat v opačném pořadí, než je X, aby se bloky správně překrývaly
		let isoCell;
		for (let mx = mapW - 1; mx >= 0; mx--) {
			for (let my = 0; my < mapH; my++) {
				let i = my * mapW + mx;
				let mCell = map[i];
				isoCell = toIso(mx, my);
				isoCell.value = mCell;				
				drawIsoCell(isoCell);			

				let wall = wallsMap[i];
				if (wall.length > 0) 
					drawImg(3, wall[0], wall[1], isoCell.ix - cellW / 2, isoCell.iy - cellH / 2, false);	
				
				let object = objectMap[i];
				if (object.length > 0) 
					drawImg(2, object[0], object[1], isoCell.ix - cellW / 2, isoCell.iy - cellH / 2, false);
			}
		}		
		
		// Update času pro animace
		let delay = timestamp - lastTime;
		lastTime = timestamp;
		
		// hero								
		let heroSpriteAdjustedX = heroSprite.vix + viewX;
		let heroSpriteAdjustedY = heroSprite.viy + viewY;
		drawImg(1, 0, animateHero(delay), heroSpriteAdjustedX, heroSpriteAdjustedY, outlines);			
	};		

	/*
	* ANIMATION
	*/
	
	let animateHero = function(delay) {
		heroSprite.timer += delay;		
		
		let diffX = virtualTargetX - heroSprite.vix;
		let diffY = heroSprite.viy - virtualTargetY;
		let angle = Math.atan(diffY / diffX) / Math.PI * 180;
		if (diffX >= 0 && diffY > 0) {
			// ok
		} else if (diffX < 0) {
			angle += 180;
		} else {
			angle += 360;		
		}
		
		if (diffX != 0 || diffY != 0) {
			let shiftX = -1 * Math.sign(diffX) * delay * hero.speed;
			// isometrické zkosení 1:2 musí snížit i rychlost
			let shiftY = -1 * Math.sign(diffY) * delay * hero.speed / 2; 
			let reductionX = diffX + shiftX;
			let reductionY = diffY + shiftY;
			if (Math.sign(reductionX) != Math.sign(diffX) || reductionX == 0) {
				heroSprite.vix = virtualTargetX;
			} else {
				heroSprite.vix -= shiftX;
			}						
			if (Math.sign(reductionY) != Math.sign(diffY) || reductionY == 0) {
				heroSprite.viy = virtualTargetY;
			} else {
				heroSprite.viy += shiftY;
			}
			
			heroSprite.currentLoop = 1;
						
			//console.log("virtualTargetX " + virtualTargetX + " heroSprite.vix " + heroSprite.vix + " viewX " + viewX);
			
			let tolerance = 5;
			
			if (angle >= 0 && angle <= tolerance || angle > (360 - tolerance) && angle <= 360) {
				hero.direction = 4; // right
			} else if (angle > tolerance && angle <= (90 - tolerance)) {
				hero.direction = 3; // right up
			} else if (angle > (90 - tolerance) && angle <= (90 + tolerance)) {
				hero.direction = 2; // up
			} else if (angle > (90 + tolerance) && angle <= (180 - tolerance)) {
				hero.direction = 1; // left up
			} else if (angle > (180 - tolerance) && angle <= (180 + tolerance)) {
				hero.direction = 0; // left
			} else if (angle > (180 + tolerance) && angle <= (270 - tolerance)) {
				hero.direction = 7; // left down
			} else if (angle > (270 - tolerance) && angle <= (270 + tolerance)) {
				hero.direction = 6; // down
			} else /* if (angle > 280 && angle <= 330) */ {
				hero.direction = 5; // right down
			}	

			adjustView();
			
		} else {
			heroSprite.currentLoop = 0;
		}		
		
		let isMirrorLoop = heroSprite.loopsMirror[heroSprite.currentLoop];
		let loopFrames = heroSprite.loopsFrames[heroSprite.currentLoop];
		let loopVirtualFrames = isMirrorLoop ? loopFrames * 2 : loopFrames;		
		
		let stepShift = Math.floor(heroSprite.timer / heroSprite.delay);
		if (stepShift > 0)
			heroSprite.timer -= stepShift * heroSprite.delay;			
		heroSprite.currentLoopStep = (heroSprite.currentLoopStep + stepShift) % loopVirtualFrames;
		
		let currentFrame = heroSprite.currentLoopStep;
		if (isMirrorLoop && currentFrame > loopFrames - 1) 
			currentFrame = loopFrames - 1 - currentFrame % loopFrames;		
			
		return heroSprite.directionFrames * hero.direction + heroSprite.loops[heroSprite.currentLoop] + currentFrame;	
	};
	
	let adjustView = function() {
		if (centered) {
			viewX = halfWidth - heroSprite.vix;
			viewY = halfHeight - heroSprite.viy;
		}
	};
	
	/*
	* INIT
	*/
	
	let init = function() {					
		let mx = mapW / 2;
		let my = mapH / 2;
		isoCenter = {
			ix: (mx - 0.5) * cellW / 2 + (my - 0.5) * cellW / 2,
			iy: my * cellH / 2 - mx * cellH / 2
		};
		
		adjustView();
		
		canvas.addEventListener("click", function (e) {								
			let bound = canvas.getBoundingClientRect();
			let targetX = e.clientX - bound.x;
			let targetY = e.clientY - bound.y;			
			virtualTargetX = targetX - viewX;
			virtualTargetY = targetY - viewY;
		});

		// ground textures		
		textures[0] = [];
		// characters textures
		textures[1] = [];
		// object textures
		textures[2] = [];
		// walls textures
		textures[3] = [];
		
		let list = [
			[0, "https://www.gattserver.cz/fm-files/isometric-files/ground/grass_medium_128x64.png", 8, 7, cellW, cellH, 0, 0],
			[0, "https://www.gattserver.cz/fm-files/isometric-files/ground/stone_path_128x64.png", 8, 7, cellW, cellH, 0, 0],			
			[0, "https://www.gattserver.cz/fm-files/isometric-files/ground/grass_dry_128x64.png", 8, 7, cellW, cellH, 0, 0],
			[1, "https://www.gattserver.cz/fm-files/isometric-files/characters/skeleton_0.png", 32, 8, heroSprite.width, heroSprite.height, 64, 128 - 52],
			[2, "https://www.gattserver.cz/fm-files/isometric-files/plants/weed03.png", 1, 1, 128, 64, 0, 0],
			[2, "https://www.gattserver.cz/fm-files/isometric-files/plants/swirl02.png", 1, 1, 128, 64, 0, 0],
			[2, "https://www.gattserver.cz/fm-files/isometric-files/plants/pine-none03.png", 1, 1, 256, 256, 64 + 16, 128 + 64],			
			[3, "https://www.gattserver.cz/fm-files/isometric-files/walls/barricade_tiles.png", 4, 3, 128, 128, 0, 64],			
		];
		
		for (let a = 0; a < list.length; a++) {
			let item = list[a];
			textures[item[0]].push({
				src: item[1],
				cols: item[2], 
				rows: item[3],
				width: item[4],
				height: item[5],
				offsetX: item[6],
				offsetY: item[7],
			});
			loadingProgress++;
		}
		
		for (let g = 0; g < textures.length; g++) {	
			let group = textures[g];
			for (let i = 0; i < group.length; i++) {
				let texture = group[i];
				let textureCanvas = document.createElement("canvas");
				textureCanvas.width = texture.width * texture.cols;
				textureCanvas.height = texture.height * texture.rows;
				
				let textureCtx = textureCanvas.getContext("2d");
				let subCanvasSmoothing = false;
				textureCtx.webkitImageSmoothingEnabled = subCanvasSmoothing;
				textureCtx.mozImageSmoothingEnabled = subCanvasSmoothing;
				textureCtx.imageSmoothingEnabled = subCanvasSmoothing;
				textureCtx.msImageSmoothingEnabled = subCanvasSmoothing; 
				
				texture.canvas = textureCanvas;
				texture.ctx = textureCtx;
				textureImg = new Image();			
				(function() {
					let seafImg = textureImg;
					let seafGroup = g;
					let seafIndex = i;
					textureImg.onload = function() {
						loadingProgress--;
						if (loadingProgress == 0)
							loaded = true;
						let tex = textures[seafGroup][seafIndex];
						tex.ctx.drawImage(seafImg, 0, 0);
						tex.imageData = tex.ctx.getImageData(0, 0, textureCanvas.width, textureCanvas.height);
					}
				})();
				textureImg.src = texture.src;
			}
		}
				
		// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas
		// https://www.html5rocks.com/en/tutorials/canvas/performance/#toc-ref
		// https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
		// https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame
		window.requestAnimationFrame(draw);		
	};	
		
	return {	
		start: function() {					
			init();						
		},		
		
		changeCentered: function(value) {
			centered = value;
		},
		
		changeOutlines: function(value) {
			outlines = value;
		},
	};

})();

$.isometricGame.start();</script>