[N1]Demo[/N1]
[HTML]<div style="margin: 10px 0;">
	<canvas id="canvasT" width="700" height="400"></canvas>
</div>[/HTML]
<script>var $ = $ || {};
$.isometric = (function() {

	let canvas = document.getElementById("canvasT");
	let ctx = canvas.getContext("2d");
	let width = canvas.width;
	let height = canvas.height;	
	let halfWidth = width / 2;
	let halfHeight = height / 2;
	
	let interval = 20;
	let innerIntervalCallback;
	
	let viewX = 0;
	let viewY = 0;
	
	let dragged = false;
	let xDraggedStart;
	let yDraggedStart;
	
	let colors = 5;
	let mapW = 9;
	let mapH = 9;
	let cellW = 80;
	let cellH = cellW / 2;
	let cellMaxLevel = 60;
	let isoCenter;
	
	let map;
		
	let toIso = function(mx, my) {
		return {
			ix: halfWidth + mx * cellW / 2 + my * cellW / 2 - isoCenter.ix + viewX, 
			iy: halfHeight + my * cellH / 2 - mx * cellH / 2 - isoCenter.iy + viewY
		};
	};
	
	let toMap = function(ix, iy) {
		return {ix: halfWidth + mx, iy: halfHeight + my};
	};
	
	let drawPolygon = function(xArr, yArr, color) {
		ctx.fillStyle = color;
		ctx.strokeStyle = "black";
		ctx.lineWidth = 1;			
		for (let d = 0; d < 2; d++) {
			ctx.beginPath();
			for (let i = 0; i < xArr.length + 1; i++) {
				let ii = i % xArr.length;
				if (i == 0) 
					ctx.moveTo(xArr[ii], yArr[ii]);
				else 
					ctx.lineTo(xArr[ii], yArr[ii]);
			}
			if (d == 0) 
				ctx.fill();
			else 
				ctx.stroke();
		}
	}
	
	let drawIsoCell = function(isoCell) {		
		let x = [isoCell.ix - cellW / 2, isoCell.ix, isoCell.ix + cellW / 2, isoCell.ix];
		let y = [isoCell.iy, isoCell.iy - cellH / 2, isoCell.iy, isoCell.iy + cellH / 2];
		let isoLevel = isoCell.level * cellMaxLevel;
		
		// Mimo view nemá cenu vykreslovat
		if (x[1] < 0 || x[3] > width || y[0] - isoLevel > height || y[2] < 0)
			return;
		
		// levá strana
		drawPolygon(
			[x[0], x[0], x[1], x[1]], 
			[y[0], y[0] - isoLevel, y[3] - isoLevel, y[3]],
			isoCell.value);
		// pravá strana
		drawPolygon(
			[x[1], x[1], x[2], x[2]], 
			[y[3], y[3] - isoLevel, y[0] - isoLevel, y[0]],
			isoCell.value);
		// plocha
		drawPolygon(
			[x[0], x[1], x[2], x[3]],
			[y[0] - isoLevel, y[1] - isoLevel, y[2] - isoLevel, y[3] - isoLevel],
			isoCell.value);
				
	};
		
	let draw = function() {	
		ctx.clearRect(0, 0, width, height);
		
		ctx.strokeStyle = "black";
		ctx.lineWidth = 1;					
		ctx.strokeRect(0, 0, width, height);
		
		ctx.beginPath();
		ctx.moveTo(halfWidth, 0);
		ctx.lineTo(halfWidth, height);
		ctx.stroke();
		
		ctx.beginPath();
		ctx.moveTo(0, halfHeight);
		ctx.lineTo(width, halfHeight);
		ctx.stroke();
		
		// map se musí vykreslovat v opačném pořadí, než je X, aby se bloky správně překrývaly
		let isoCell;
		for (let mx = mapW - 1; mx >= 0; mx--) {
			for (let my = 0; my < mapH; my++) {
				let mCell = map[mx][my];
				isoCell = toIso(mx, my);
				isoCell.value = mCell.value;
				isoCell.level = mCell.level;
				drawIsoCell(isoCell);	
				// update výšky
				mCell.level += mCell.speed;
				if (mCell.level  < 0 || mCell.level > 1) {
					mCell.speed *= -1;					
					mCell.level += mCell.speed;
				}
			}
		}		
	};
				
	
	let innnerChangeInterval = function(value) {
		if (isNaN(value))
			return;
		let newValue = Number(value);
		if (newValue < 1)
			return;
		console.log("interval changed from '" + interval + "' to '" + newValue + "'");
		interval = newValue;
		
		if (innerIntervalCallback) 
			clearInterval(innerIntervalCallback);
		
		innerIntervalCallback = setInterval(function() {
			draw();
		}, interval);
	};
	
	let init = function() {	
		ctx.lineWidth = 2;				
		innnerChangeInterval(interval);	
		
		let centerMx = Math.floor(mapW / 2);
		let centerMy = Math.floor(mapH / 2);
		isoCenter = {
			ix: centerMx * cellW / 2 + centerMy * cellW / 2,
			iy: centerMy * cellH / 2 - centerMx * cellH / 2 
		};
		
		map = [];
		for (let mx = 0; mx < mapW; mx++) {
			let row = [];
			map[mx] = row;
			for (let my = 0; my < mapH; my++) {
				//let color = (Math.floor(Math.random() * colors) * 360 / colors);				
				let color = (mx * mapH + my) * 360 / (mapW * mapH);
				row[my] = {
					value: "hsl(" + color + ", 100%, 50%)",
					speed: Math.random() * 0.1,
					level: Math.random()
				}
			}
		}
		
	};	
	
	canvas.addEventListener("mousedown", function (e) {
		dragged = true;
		xDraggedStart = e.clientX;
		yDraggedStart = e.clientY;
	}, false);
 
	canvas.addEventListener("mouseup", function (e) {
		dragged = false;
	}, false);
	
	canvas.addEventListener("mouseleave", function (e) {
		dragged = false;
	}, false);
	
	canvas.addEventListener("mousemove", function (e) {
		if (!dragged) 
			return;
		viewX -= (xDraggedStart - e.clientX);
		viewY -= (yDraggedStart - e.clientY);
		xDraggedStart = e.clientX;
		yDraggedStart = e.clientY;		
	}, false);
	
	canvas.addEventListener("dblclick", function (e) {
		viewX = 0;
		viewY = 0;
	}, false);
		
	return {

		start: function() {					
			init();						
		},
		
	};

})();

$.isometric.start();</script>