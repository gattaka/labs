[HTML]<table>
	<tbody>
		<tr>
			<td>View angle (0-360°)</td>
			<td>Ray width (5-1)</td>
		</tr>
		<tr>
			<td><input id="viewAngle" 
				onchange="$.perspective.changeViewAngle(this.value)" style="width: 80px;" value="90"></td>
			<td><input id="rayWidth"
				onchange="$.perspective.changeRayWidth(this.value)" style="width: 80px;" value="5"></td>
		</tr>
	</tbody>
</table>
<div style="margin: 10px 0; border: 1px solid red; display: inline-block;">
	<canvas id="perspectiveCanvas" width="700" height="400"></canvas>
</div>
<div style="margin: 10px 0; border: 1px solid red; display: inline-block;">
	<canvas id="minimapCanvas" width="700" height="400"></canvas>
</div>[/HTML]
<script>var $ = $ || {};
$.perspective = (function() {

	let canvas = document.getElementById("perspectiveCanvas");
	let ctx = canvas.getContext("2d");
	let width = canvas.width;
	let height = canvas.height;
	let halfWidth = width / 2; 
	let halfHeight = height / 2;
	
	let minimapCanvas = document.getElementById("minimapCanvas");
	let minimapCtx = minimapCanvas.getContext("2d");
	let minimapWidth = minimapCanvas.width;
	let minimapHeight = minimapCanvas.height;
	let minimapHalfWidth = minimapWidth / 2; 
	let minimapHalfHeight = minimapHeight / 2;
	
	let interval = 20;
	let innerIntervalCallback;
	
	// Jednotky
	// CLU -- cell unit, jednotka buňky mapy = 1
	// MVU -- map unit, jednotka virtuální mapy
	// MMU -- minimapk unit, jednotka zobrazení minimapy
	// SCU -- scena unit, jednotka zobrazení scény
	
	// kolik jednotek má dílek mapy
	let cluToMvu = 20;
	let mvuToMmu = 1.2;
			
	// Wolfenstein typ -- dílky mapy mají konstantní velikost, 
	// nemají patra a jsou vždy na sebe kolmé
	// 0 = prázdno
	// 1 = díl mapy (kostka) se zdmi typu 1
	let mapRows = 7;
	let mapCols = 10;
	let map = [
		[0,1,2,1,4,5,6,1,0,0],
		[0,6,0,0,0,0,0,3,2,0],
		[3,2,0,0,0,0,0,0,1,1],
		[5,0,0,0,0,0,0,0,0,4],
		[4,2,0,0,1,0,0,0,0,1],
		[0,3,0,0,0,0,0,0,0,4],
		[0,1,7,1,9,7,5,2,1,8]
	];
	
	// hranice
	let minXMvu = 0;
	let minYMvu = 0;
	let maxXMvu = (mapCols + 1) * cluToMvu;
	let maxYMvu = (mapRows + 1) * cluToMvu;
		
	// pozice a orientace hráče na mapě
	let playerXMvu = mapCols / 2 * cluToMvu;
	let playerYMvu = mapRows / 2 * cluToMvu;
	let playerOrient = 270; // 0-360	
	
	// rozsah v jakém hráč vidí
	let angleWidthRes = 5;
	let angleRes = width / angleWidthRes;
	let angleRange = 90;
	let angleIncrement = angleRange / angleRes;		
	let rayStepMvu = 5;		
	let perspectiveLen = 0.5;	
	
	let cursorSideMmu = 10;
	
	let walkSpeedStepMvu = 2; 
	let turnSpeedStep = 3;
	let walkSpeedMvu = 0;
	let turnSpeed = 0;
	
	let init = function() {		
		document.addEventListener("keydown", onKeyDown);
		document.addEventListener("keyup", onKeyUp);
	
		innerIntervalCallback = setInterval(function() {
			draw();
		}, interval);			
	};		
	
	let onKeyDown = function(event) {
		switch (event.keyCode) {
		case 87: 
			walkSpeedMvu = walkSpeedStepMvu;
			break;
		case 83: 
			walkSpeedMvu = -walkSpeedStepMvu;
			break;
		case 65: 
			turnSpeed = -turnSpeedStep;
			break;
		case 68: 
			turnSpeed = turnSpeedStep;
			break;
		}
	};
	
	let onKeyUp = function(event) {
		switch (event.keyCode) {
		case 87: 
		case 83: 
			walkSpeedMvu = 0;
			break;			
		case 65: 
		case 68: 
			turnSpeed = 0;
			break;
		}
	};

	let mapColor = function(id) {
		if (id == 0) 		
			return "black";
		let hue = id * 255 / 10;
		return "hsl(" + hue + ", 100%, 50%)";
	};

	let toRad = function(angle) {
		return Math.PI * angle / 180;
	};
	
	let xMvuToMmu = function(xMvu) {
		return minimapHalfWidth - (mapCols / 2 * cluToMvu - xMvu) * mvuToMmu;
	};
	
	let yMvuToMmu = function(yMvu) {
		return minimapHalfHeight - (mapRows / 2 * cluToMvu - yMvu) * mvuToMmu;
	};

	let draw = function() {		
		updatePlayer();
		drawMinimap();
		drawScene();
	};
	
	let updatePlayer = function() {
		playerOrient += turnSpeed;
							
		let draftPlayerXMvu = playerXMvu + Math.cos(toRad(playerOrient)) * walkSpeedMvu;
		let draftPlayerYMvu = playerYMvu + Math.sin(toRad(playerOrient)) * walkSpeedMvu;
		let draftPlayerXClu = Math.floor(draftPlayerXMvu / cluToMvu);
		let draftPlayerYClu = Math.floor(draftPlayerYMvu / cluToMvu);
		if (draftPlayerYClu >= 0 && draftPlayerYClu < mapRows && draftPlayerXClu >= 0 && draftPlayerXClu <= mapCols) {
			cellValue = map[draftPlayerYClu][draftPlayerXClu];
			if (cellValue == 0) {
				playerXMvu = draftPlayerXMvu;
				playerYMvu = draftPlayerYMvu;
			}
		}
	};
	
	let drawScene = function() {			
		ctx.fillStyle = "black";
		ctx.fillRect(0, 0, width, height);
						
		// minimap info
		let playerXMmu = xMvuToMmu(playerXMvu);
		let playerYMmu = yMvuToMmu(playerYMvu);
							
		let angleRadStart = toRad(playerOrient - angleRange / 2);
		let angleRadStop = toRad(playerOrient + angleRange / 2);
		let angleRadIncrement = toRad(angleIncrement);
		for (let angleRad = angleRadStart, x = 0; angleRad < angleRadStop; angleRad += angleRadIncrement, x += angleWidthRes) {		
			let rayXStepMvu = Math.cos(angleRad) * rayStepMvu;
			let rayYStepMvu = Math.sin(angleRad) * rayStepMvu;			
			let rayXMvu = playerXMvu;
			let rayYMvu = playerYMvu;
			
			let cellValue = 0;
			while (cellValue == 0 && rayXMvu > minXMvu && rayXMvu < maxXMvu && rayYMvu > minYMvu && rayYMvu < maxYMvu) {
				rayXMvu += rayXStepMvu;
				rayYMvu += rayYStepMvu;
				let yClu = Math.floor(rayYMvu / cluToMvu);
				let xClu = Math.floor(rayXMvu / cluToMvu);
				if (yClu >= 0 && yClu < mapRows && xClu >= 0 && xClu <= mapCols) {
					cellValue = map[yClu][xClu];	
				} else {
					cellValue = 0;
				}				
				if (cellValue != 0)
					break;
			}
			
			// minimap ray show
			let rayXMmu = xMvuToMmu(rayXMvu);
			let rayYMmu = yMvuToMmu(rayYMvu);
			
			minimapCtx.lineWidth = 2; 
			minimapCtx.strokeStyle = "white"; 
			minimapCtx.moveTo(playerXMmu, playerYMmu);
			minimapCtx.lineTo(rayXMmu, rayYMmu);
			minimapCtx.stroke();
											
			if (cellValue != 0) {
				let distance = Math.sqrt(Math.pow(playerXMvu - rayXMvu, 2) + Math.pow(playerYMvu - rayYMvu, 2));
				let yDiff = distance * perspectiveLen;
				let segmentHeight = height - yDiff * 2;
				ctx.fillStyle = mapColor(cellValue);
				ctx.fillRect(x, yDiff, angleWidthRes, segmentHeight);
			}
		}					
	}
	
	let drawMinimap = function() {
		minimapCtx.fillStyle = "black";
		minimapCtx.fillRect(0, 0, minimapWidth, minimapHeight);

		let minimapCellSize = cluToMvu * mvuToMmu;

		for (let row = 0; row < mapRows; row++) {	
			let rowData = map[row];
			let y = minimapHalfHeight - (Math.floor(mapRows / 2) - row) * minimapCellSize - minimapCellSize / 2;
			for (let col = 0; col < mapCols; col++) {
				let colData = rowData[col];
				if (colData == 0)
					continue;
				let x = minimapHalfWidth - (Math.floor(mapCols / 2) - col) * minimapCellSize;
				minimapCtx.fillStyle = mapColor(colData); 
				minimapCtx.fillRect(x, y, minimapCellSize, minimapCellSize);
			}
		}
		
		drawCursor();
	};
	
	let drawCursor = function() {
		minimapCtx.strokeStyle = "red";		
		minimapCtx.beginPath();
		
		let playerXMmu = xMvuToMmu(playerXMvu);
		let playerYMmu = yMvuToMmu(playerYMvu);
		
		let orientRad = toRad(playerOrient)
		let midVertX = playerXMmu + Math.cos(orientRad) * cursorSideMmu;
		let midVertY = playerYMmu + Math.sin(orientRad) * cursorSideMmu;
		
		let leftVertRad = orientRad + Math.PI * 1.25;
		let leftVertX = playerXMmu + Math.cos(leftVertRad) * cursorSideMmu;
		let leftVertY = playerYMmu + Math.sin(leftVertRad) * cursorSideMmu;
		
		let rightVertRad = orientRad - Math.PI * 1.25;
		let rightVertX = playerXMmu + Math.cos(rightVertRad) * cursorSideMmu;
		let rightVertY = playerYMmu + Math.sin(rightVertRad) * cursorSideMmu;
		
		minimapCtx.lineWidth = 2; 
		minimapCtx.strokeStyle = "red"; 
		minimapCtx.moveTo(leftVertX, leftVertY);
		minimapCtx.lineTo(midVertX, midVertY);
		minimapCtx.lineTo(rightVertX, rightVertY);
		minimapCtx.stroke();
	};	

	return {
	
		start: function() {	
			init();			
		},	
		
		changeViewAngle: function(value) {
			console.log("viewAngle changed from '" + angleRange + "' to '" + value + "'");
			angleRange = value;
			angleIncrement = angleRange / angleRes;	
		},
		
		changeRayWidth: function(value) {
			console.log("rayWidth changed from '" + angleWidthRes + "' to '" + value + "'");
			angleWidthRes = value;
			angleRes = width / angleWidthRes;			
			angleIncrement = angleRange / angleRes;	
		},
	};

})();

$.perspective.start();</script>