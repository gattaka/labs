<div style="margin: 10px 0; border: 1px solid red; display: inline-block;">
	<canvas id="perspectiveCanvas" width="700" height="400"></canvas>
</div>
<div style="margin: 10px 0; border: 1px solid red; display: inline-block;">
	<canvas id="minimapCanvas" width="700" height="400"></canvas>
</div>
<script>var $ = $ || {};
$.perspective = (function() {

	let canvas = document.getElementById("perspectiveCanvas");
	let ctx = canvas.getContext("2d");
	let width = canvas.width;
	let height = canvas.height;
	let halfWidth = width / 2; 
	let halfHeight = height / 2;
	
	let minimapCanvas = document.getElementById("minimapCanvas");
	let minimapCtx = minimapCanvas.getContext("2d");
	let minimapWidth = minimapCanvas.width;
	let minimapHeight = minimapCanvas.height;
	let minimapHalfWidth = minimapWidth / 2; 
	let minimapHalfHeight = minimapHeight / 2;
	
	let interval = 20;
	let innerIntervalCallback;
	
	// kolik jednotek má dílek mapy
	let mapResolution = 20;
			
	// Wolfenstein typ -- dílky mapy mají konstantní velikost, 
	// nemají patra a jsou vždy na sebe kolmé
	// 0 = prázdno
	// 1 = díl mapy (kostka) se zdmi typu 1
	let mapRows = 7;
	let mapCols = 10;
	let map = [
		[0,1,2,1,4,5,6,1,0,0],
		[0,6,0,0,0,0,0,3,2,0],
		[3,2,0,0,0,0,0,0,1,1],
		[5,0,0,0,0,0,0,0,0,4],
		[4,2,0,0,1,0,0,0,0,1],
		[0,3,0,0,0,0,0,0,0,4],
		[0,1,7,1,9,7,5,2,1,8]
	];
	
	// hranice
	let mapMinX = 0;
	let mapMinY = 0;
	let mapMaxX = (mapCols + 1) * mapResolution;
	let mapMaxY = (mapRows + 1) * mapResolution;
		
	// pozice a orientace hráče na mapě
	let playerMapX = mapCols / 2 * mapResolution;
	let playerMapY = mapRows / 2 * mapResolution;
	let playerOrient = 270; // 0-360	
	
	// rozsah v jakém hráč vidí
	let angleWidthRes = 5;
	let angleRes = width / angleWidthRes;
	let angleRange = 90;
	let angleIncrement = angleRange / angleRes;		
	let rayStep = 5;		
	let perspectiveLen = 0.5;	
	
	// rozlišení minimapy (dílek -> px)
	let minimapResolution = 1.2;
	let minimapCursorSide = 10;
	
	let walkSpeedStep = 2; 
	let turnSpeedStep = 3;
	let walkSpeed = 0;
	let turnSpeed = 0;
	
	let init = function() {		
		document.addEventListener("keydown", onKeyDown);
		document.addEventListener("keyup", onKeyUp);
	
		innerIntervalCallback = setInterval(function() {
			draw();
		}, interval);			
	};		
	
	let onKeyDown = function(event) {
		switch (event.keyCode) {
		case 38: 
			walkSpeed = walkSpeedStep;
			break;
		case 40: 
			walkSpeed = -walkSpeedStep;
			break;
		case 37: 
			turnSpeed = -turnSpeedStep;
			break;
		case 39: 
			turnSpeed = turnSpeedStep;
			break;
		}
	};
	
	let onKeyUp = function(event) {
		switch (event.keyCode) {
		case 38: 
		case 40: 
			walkSpeed = 0;
			break;			
		case 37: 
		case 39: 
			turnSpeed = 0;
			break;
		}
	};

	let mapColor = function(id) {
		if (id == 0) 		
			return "black";
		let hue = id * 255 / 10;
		return "hsl(" + hue + ", 100%, 50%)";
	};

	let toRad = function(angle) {
		return Math.PI * angle / 180;
	};

	let draw = function() {						
		ctx.fillStyle = "black";
		ctx.fillRect(0, 0, width, height);
		
		playerOrient += turnSpeed;
		playerMapX += Math.cos(toRad(playerOrient)) * walkSpeed;
		playerMapY += Math.sin(toRad(playerOrient)) * walkSpeed;
							
		let angleRadStart = toRad(playerOrient - angleRange / 2);
		let angleRadStop = toRad(playerOrient + angleRange / 2);
		let angleRadIncrement = toRad(angleIncrement);
		for (let angleRad = angleRadStart, x = 0; angleRad < angleRadStop; angleRad += angleRadIncrement, x += angleWidthRes) {		
			let rayXStep = Math.cos(angleRad) * rayStep;
			let rayYStep = Math.sin(angleRad) * rayStep;			
			let rayX = playerMapX;
			let rayY = playerMapY;
			
			let cellValue = 0;
			while (cellValue == 0 && rayX > mapMinX && rayX < mapMaxX && rayY > mapMinY && rayY < mapMaxY) {
				rayX += rayXStep;
				rayY += rayYStep;
				let mapRow = Math.floor(rayY / mapResolution);
				let mapCol = Math.floor(rayX / mapResolution);
				if (mapRow >= 0 && mapRow < mapRows && mapCol >= 0 && mapCol <= mapCols) {
					cellValue = map[mapRow][mapCol];				
				} else {
					cellValue = 0;
				}				
			}
											
			if (cellValue != 0) {
				let distance = Math.sqrt(Math.pow(playerMapX - rayX, 2) + Math.pow(playerMapY - rayY, 2));
				let yDiff = distance * perspectiveLen;
				let segmentHeight = height - yDiff * 2;
				ctx.fillStyle = mapColor(cellValue);
				ctx.fillRect(x, yDiff, angleWidthRes, segmentHeight);
			}
		}
				
		drawMinimap();
	}
	
	let drawMinimap = function() {
		minimapCtx.fillStyle = "black";
		minimapCtx.fillRect(0, 0, minimapWidth, minimapHeight);

		let minimapCellSize = mapResolution * minimapResolution;

		for (let row = 0; row < mapRows; row++) {	
			let rowData = map[row];
			let y = minimapHalfHeight - (Math.floor(mapRows / 2) - row) * minimapCellSize;
			for (let col = 0; col < mapCols; col++) {
				let colData = rowData[col];
				if (colData == 0)
					continue;
				let x = minimapHalfWidth - (Math.floor(mapCols / 2) - col) * minimapCellSize;
				minimapCtx.fillStyle = mapColor(colData); 
				minimapCtx.fillRect(x, y, minimapCellSize, minimapCellSize);
			}
		}
		
		drawCursor();
	};
	
	let drawCursor = function() {
		minimapCtx.strokeStyle = "red";		
		minimapCtx.beginPath();
		
		let centerX = minimapHalfWidth - (mapCols / 2 * mapResolution - playerMapX) * minimapResolution;
		let centerY = minimapHalfHeight - (mapRows / 2 * mapResolution - playerMapY) * minimapResolution;
		
		let orientRad = toRad(playerOrient)
		let midVertX = centerX + Math.cos(orientRad) * minimapCursorSide;
		let midVertY = centerY + Math.sin(orientRad) * minimapCursorSide;
		
		let leftVertRad = orientRad + Math.PI * 1.25;
		let leftVertX = centerX + Math.cos(leftVertRad) * minimapCursorSide;
		let leftVertY = centerY + Math.sin(leftVertRad) * minimapCursorSide;
		
		let rightVertRad = orientRad - Math.PI * 1.25;
		let rightVertX = centerX + Math.cos(rightVertRad) * minimapCursorSide;
		let rightVertY = centerY + Math.sin(rightVertRad) * minimapCursorSide;
		
		minimapCtx.lineWidth = 2; 
		minimapCtx.strokeStyle = "red"; 
		minimapCtx.moveTo(leftVertX, leftVertY);
		minimapCtx.lineTo(midVertX, midVertY);
		minimapCtx.lineTo(rightVertX, rightVertY);
		minimapCtx.stroke();
	};	

	return {
		start: function() {	
			init();			
		},	
	};

})();

$.perspective.start();</script>