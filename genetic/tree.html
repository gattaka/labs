<html>
<div>
	<canvas id="canvas" width="800" height="600"></canvas>
</div>
<script>
let genetics = (() => {

	/*
	- Stromy
		- gen-rand = pravděpodobnost, že se něco bude dít, dána genem jedince
		- gen-stat = hodnota, dána genem jedince
	- Dvě fáze
		- fáze růstu
			- zakládají se listy nebo se z listů tvoří větve
				- větev ani list nesmí narazit do obsazeného čtverce
				- list nemůže růst tam, kde nad ním je jiný list (větev nevadí)
			- zakládání stojí energii, kterou musí mít strom v "banku"
			- gen-rand určuje, zda se bude měnit list na větev nebo se bude tvořit nový list
			- místo ze kterého může vyrůst nový list se vybírá náhodně
				- bere se ale v potaz vzdálenost od nějakého jiného listu
				- gen-rand určuje je velký prostor je umožněn pro růst 
					- jestli smí list vyrůst jen na 2 dílky vzdálené větvi od jiného listu, nebo může i na kmení		
		- fáze sbírání energie
			- všem větvím a listům se nastaví stav--
			- prochází se postupně všechny listy a ty posílají "energii" přes předky zpět ke koření
			- přes koho projde energie, dá si stav++
			- ty větve nebo listy, které mají stav = 0 jsou suché a mízí
			- zbytek, co dojde do kořene se přičte k banku
	*/

	// gen simulace
	let geneLength;
	let generations;
	let creaturesCount;
	let creatures;
	let fullMask;
	let lowerHalfMask;
	let higherHalfMask;
	let eliteCount;
	let idiotsCount;
	let mutationsCount;
	
	// gen prostředí
	let cells;
	let lights;
	let cellSize;
	let trees;
	let cWidth;
	let cHeight;
	
	// statistiky
	let allTimeBestGeneration;
	let allTimeBestFitness;
	let allTimeBestCreature;
	let generationBestPrices;
	let allTimeBestPrices;
	
	// simulátor
	let delay;
	let innerIntervalCallback;
	let canvas = document.getElementById("canvas");
	let ctx = canvas.getContext("2d");
	let width = canvas.width;
	let height = canvas.height;	
	
	// utility funkce
	
	let printBinary = function(creature) {
		let result = "";
		let mask = 1;
		for (let i = 0; i < items.length; i++) {
			result = (((creature & mask) > 0) ? 1 : 0) + result;		
			mask = mask << 1;
		}
		return result;
	};

	let toRad = (angle) => {
		return Math.PI / 180 * angle;
	};

	// obecné gen funkce

	let fight = function(creatureA, creatureB) {
		let fa = fitness(creatureA)[1];
		let fb = fitness(creatureB)[1];
		if (fa > fb)
			return -1;
		if (fa < fb)
			return 1;
		return 0;
	};
	
	let mate = function(creatureA, creatureB) {		
		return (creatureA & higherHalfMask) + (creatureB & lowerHalfMask);	
	};

	let mutate = function(creature) {		
		let index = Math.floor(Math.random() * items.length);
		let mask = 1 << index;
		creature += (creature & mask > 0) ? - mask : mask;
		return creature;
	};

	let createNewGeneration = (parents) => {
		let newCreatures = [];
		while (true) {
			for (let a = 0; a < parents.length; a++) {
				for (let b = 0; b < parents.length; b++) {
					let newCreature = mate(parents[a], parents[b]);
					for (let c = 0; c < mutationsCount; c++)
						newCreature = mutate(newCreature);
					newCreatures[newCreatures.length] = newCreature;
					if (newCreatures.length == creatures.length)
						return newCreatures;
				}
			}				
		}
	};

	let initPopulation = () => {
		// rovnoměrně roprostřít
		let max = 1 << geneLength;
		let step = max / creaturesCount;
		creatures = [];
		for (let c = 0; c < max; c += step)
			creatures[creatures.length] = Math.floor(c);		
	};
	
	// konkrétní gen funkce pro daný experiment

	let fitness = (creature) => {
		// TODO
		let w = 0;
		let p = 0;
		let mask = 1;
		for (let i = 0; i < geneLength; i++) {
			// nemá cenu dál maskovat, pokud už creature 
			// nemá další vyšší 1, než má maska
			if (mask > creature)
				return [w, p];
			if ((creature & mask) > 0) {				
				w += items[i][0];
				if (w > backpackWeight) 
					return [w, -1];
				p += items[i][1];
			}
			mask = mask << 1;
		}
		return [w, p];
	};

	let node = {
		cx: 0,
		cy: 0,
		parent: {},
		tree: {},
		leaf: 0,
		health: 0
	};

	let tree = {		
		cx: 0, // pozice
		dna: {
			leafPower: 0, // výkon listu -- energie, kterou dodává každý list
			leafToBranchProb: 0, // pravděpodobnost, že z dané větve vyroste nový list namísto další větve
			nodeHealth: 0, // kolik energie/zdraví bude stát/mít nová větev nebo list (u listu je to ještě navíc jeho výkon)		
		},
		age: 0, // stáří stromu
		energy: 0, // aktuální energie		
		nodes: [] // struktura	
	};

	let getCell = (cx, cy) => {
		if (!isValidPosition(cx, cy))
			return null;
		return cells[cy * cWidth + cx];
	};
	
	let isValidPosition = (cx, cy) => {
		return cx < cWidth && cx >= 0 && cy < cHeight && cy >= 0		
	};
	
	let isCellEmptyOrNode = (node, cx, cy) => {
		if (!isValidPosition(cx, cy))
			return false;
		let val = getCell(cx, cy);
		return val == node || !val;
	};
	
	let isFree = (node, cx, cy) => {
		if (getCell(cx, cy) || !isValidPosition(cx, cy))
			return false;
		return true;
			/*
		return isCellEmptyOrNode(node, cx - 1, cy - 1) && 
			   isCellEmptyOrNode(node, cx, cy - 1) &&
			   isCellEmptyOrNode(node, cx + 1, cy - 1) &&
			   isCellEmptyOrNode(node, cx - 1, cy) && 
			   ! &&
			   isCellEmptyOrNode(node, cx + 1, cy) &&
			   isCellEmptyOrNode(node, cx - 1, cy + 1) && 
			   isCellEmptyOrNode(node, cx, cy + 1) &&
			   isCellEmptyOrNode(node, cx + 1, cy + 1);
			   */
	};

	let grow = () => {		
		for (let i = 0; i < trees.length; i++) {
			let tree = trees[i];
			tree.age++;
			while (tree.energy >= tree.dna.nodeHealth) {
				let creatingLeaf;
				if (tree.energy < tree.dna.nodeHealth + tree.dna.leafPower) {
					// je lepší přeskočit toto kolo, protože jinak strom bude stále stavět jen větve a žádné listy
					break;		
				} else {
					creatingLeaf = Math.random() * 100 > tree.dna.leafToBranchProb;
				}
				let success = false;
				let offset = Math.floor(Math.random() * tree.nodes.length);
				for (let j = 0; j < tree.nodes.length; j++) {					
					let node = tree.nodes[(j + offset) % tree.nodes.length];
					if (!node)
						continue;
					if (!node.leaf) {
						// TODO DNA preference směru růstu 
						offset = Math.floor(Math.random() * 8);
						for (let k = 0; k < 8; k++) {
							let dir = Math.floor((k + offset) % 8);
							let ncx = node.cx;
							let ncy = node.cy;
							switch (dir) {
								case 0:
									ncy = node.cy + 1;
									break;
								case 1:
									ncy = node.cy - 1;
									break;
								case 2:
									ncx = node.cx + 1;
									break;
								case 3:
									ncx = node.cx - 1;
									break;
								case 4:
									ncx = node.cx + 1;
									ncy = node.cy + 1;
									break;
								case 5:
									ncx = node.cx + 1;
									ncy = node.cy - 1;
									break;
								case 6:
									ncx = node.cx - 1;
									ncy = node.cy + 1;
									break;
								case 7:
									ncx = node.cx - 1;
									ncy = node.cy - 1;
									break;
							}
							if (isFree(node, ncx, ncy)) {
								if (creatingLeaf) {
									if (!lights[ncx] || ncy > lights[ncx].cy) {
										let newLeaf = {
											cx: ncx,
											cy: ncy,
											parent: node,
											nodes: [],
											tree: tree,
											leaf: true,
											health: tree.dna.nodeHealth
										}
										node.nodes.push(newLeaf);
										tree.nodes.push(newLeaf);
										lights[ncx] = newLeaf;
										cells[ncy * cWidth + ncx] = newLeaf;
										success = true;
										break;
									}
								} else {
									let newBranch ={
										cx: ncx,
										cy: ncy,
										parent: node,
										nodes: [],
										tree: tree,
										leaf: false,
										health: tree.dna.nodeHealth
									}
									node.nodes.push(newBranch);
									tree.nodes.push(newBranch);
									cells[ncy * cWidth + ncx] = newBranch;
									success = true;
									break;
								}
							}
						}
					}
					if (success)
						break;
				}
				if (success) {
					tree.energy -= tree.dna.nodeHealth;
					if (creatingLeaf)
						tree.energy -= tree.dna.leafPower;
				} else {
					// energie je, ale není co kam dát
					break;
				}
			}
		}
	};
	
	let gatherRec = (node, energy) => {
		node.health++;
		if (node.parent) {
			gatherRec(node.parent, energy - 1);
		} else {
			node.tree.energy += energy;
		}
	};
	
	let killNode = (node) => {
		node.health = 0;
		cells.splice(node.cy * cWidth + node.cx, 1)		
		// TODO lights by měl být stack
		//if (lights[node.cx] == node)
		//	lights
		
		// pokud uschnula větev, uschne vše na ní
		for (let i = 0; i < node.nodes.length; i++)
			killNode(node.nodes[i]);
	};
	
	let gather = () => {		
		for (let i = 0; i < trees.length; i++) {
			let tree = trees[i];
			tree.age++;
			for (let j = 0; j < tree.nodes.length; j++) {
				let node = tree.nodes[j];
				if (!node)
					continue;
				// tímhle se zajistí, že časem věci bez světla uschnou
				node.health--;								
				// pokud jsi list a svítí na tebe světlo
				if (node.leaf && lights[node.cx] == node) 
					gatherRec(node, tree.dna.leafPower);									
			}
			for (let j = 0; j < tree.nodes.length; j++) {
				// uschlé větve opadávají
				let node = tree.nodes[j];
				if (!node)
					continue;
				if (node.health == 0) {		
					killNode(node);
					
					// pokud uschnul kmen, strom je mrtev
					if (!node.parent) {					
						trees.splice(i, 1);
						break;
					}
				}
			}
			for (let j = 0; j < tree.nodes.length; j++) {
				if (tree.nodes[j].health == 0) {
					tree.nodes.splice(j, 1);
					j--; // korekce, aby se nepřeskočili elementy (upravuji pole, přes které právě iteruji)
				}
			}
		}
	};

	let paintTrees = () => {	
		ctx.clearRect(0, 0, width, height);
		ctx.strokeStyle = "black";
		ctx.strokeRect(0, 0, width, height);		
				
		for (let i = 0; i < trees.length; i++) {
			let tree = trees[i];
			for (let j = 0; j < tree.nodes.length; j++) {
				let node = tree.nodes[j];
				if (!node)
					continue;		
				if (node.parent) {
					ctx.beginPath();
					ctx.moveTo(node.cx * cellSize + cellSize * 0.5, height - cellSize * 0.5 - node.cy * cellSize);
					ctx.lineTo(node.parent.cx * cellSize + cellSize * 0.5, height - cellSize * 0.5 - node.parent.cy * cellSize);
					ctx.stroke();
				}
					
				ctx.fillStyle = node.leaf ? "green" : "black";
				ctx.fillRect(node.cx * cellSize + cellSize * 0.25, height - cellSize * 0.75 - node.cy * cellSize, cellSize / 2, cellSize / 2);
			}
		}
		
		//for (let c = 0; c < creatures.length; c++) {			
			
		//}
	};

	let runGeneration = (generation) => {
		paintTrees();
		grow();
		gather();
		/*if (generation < generations) {
		
			// seřadit
			creatures.sort(fight);

			let bestFitness = fitness(creatures[0]);			
			document.getElementById("resultGeneration").value = generation + 1;
			document.getElementById("resultPrice").value = bestFitness[1];
			document.getElementById("resultWeight").value = bestFitness[0];
			document.getElementById("resultConfiguration").value = printBinary(creatures[0]);
			generationBestPrices[generationBestPrices.length] = bestFitness[1];

			if (allTimeBestGeneration == -1 || bestFitness[1] >= allTimeBestFitness[1]) {
				allTimeBestCreature = creatures[0];
				allTimeBestGeneration = generation + 1;
				allTimeBestFitness = bestFitness;
				allTimeBestPrices[allTimeBestPrices.length] = allTimeBestFitness[1];
				document.getElementById("resultGenerationAll").value = allTimeBestGeneration;
				document.getElementById("resultPriceAll").value = allTimeBestFitness[1];
				document.getElementById("resultWeightAll").value = allTimeBestFitness[0];
				document.getElementById("resultConfigurationAll").value = 
					printBinary(allTimeBestCreature);
			}

			// vykreslit
			paintLife();
			grow();		

			// namnožit novou generaci
			let parents = [];
			// elity
			for (let c = 0; c < eliteCount; c++) 
				parents[parents.length] = creatures[c];			
			// idioti
			for (let c = 0; c < idiotsCount; c++)
				parents[parents.length] = creatures[creatures.length - 1 - c];			
			creatures = createNewGeneration(parents);
*/
			setTimeout(function() {
				runGeneration(generation + 1);
			}, delay);
			/*
		} else {
			// TODO
			return;	
		} 
		*/
	};
	
	let validate = (msg, field, min, max) => {
		let value = document.getElementById(field).value;
		if (isNaN(value)) {
			alert(msg);
			return false;
		}
		value = Number(value);
		if (value < min || value > max) {
			alert(msg);
			return false;
		}
		return value;
	};

	return {
		start: () => {
			
			// Cykl:
			// 1. využij nějakou energii na tvorbu nových větví a listů
			// 2. použij nově získanou plochu listů k získání energie na další cykl
			// 3. opakuj
			
			// Geny
			// 1. kolik energie předávám potomkům
			// 2. pod jakým úhlem mi rostou větve
			// 3. jakou vzdálenost mají větve od sebe (než spustím další větve)
			
			// Konstanty
			// 1. kolik energie stojí růst větve o jednotku
			// 2. kolik energie stojí založení nové větve
			
			geneLength = 0;
			generations = 200;
			creaturesCount = 50
			eliteCount = 5;
			idiotsCount = 1;
			mutationsCount = 2;
			delay = 50;
				
			trees = [];
			cellSize = 20;
			lights = [];
			cells = [];
			
			cWidth = Math.floor(width / cellSize);
			cHeight = Math.floor(height / cellSize);

			// test
			let tree = {
				cx: Math.floor(width / cellSize / 2), // pozice
				dna: {
					leafPower: 10, // výkon listu -- energie, kterou dodává každý list
					leafToBranchProb: 70, // pravděpodobnost, že z dané větve vyroste nový list
					nodeHealth: 3, // kolik energie/zdraví bude stát/mít nová větev nebo list (u listu je to ještě navíc jeho výkon			
				},
				age: 0, // stáří stromu
				energy: 10, // aktuální energie	(startovací energie je zároveň energie potřebná pro založení semínka)
				nodes: [] // struktura	
			};
			trees.push(tree);
			tree.nodes.push({
				cx: Math.floor(cWidth / 2),
				cy: 0,
				parent: null,
				nodes: [],
				tree: tree,
				leaf: false,
				health: tree.dna.nodeHealth
			});
			tree.nodes.push({
				cx: tree.nodes[0].cx + 1,
				cy: 0,
				parent: tree.nodes[0],
				nodes: [],
				tree: tree,
				leaf: true,
				health: tree.dna.nodeHealth
			});
			tree.nodes[0].nodes.push(tree.nodes[1]);
			lights[tree.nodes[1].cx] = tree.nodes[1];
			
			cells[tree.nodes[0].cy * cWidth + tree.nodes[0].cx] = tree.nodes[0];
			cells[tree.nodes[1].cy * cWidth + tree.nodes[1].cx] = tree.nodes[1];
			
			allTimeBestGeneration = -1;
			allTimeBestFitness = [];
			allTimeBestCreature = -1;
			
			generationBestPrices = [];
			allTimeBestPrices = [];
		
			fullMask = (1 << geneLength) - 1;
			lowerHalfMask = (1 << Math.floor(geneLength / 2)) - 1;
			higherHalfMask = fullMask - lowerHalfMask;			

			ctx.clearRect(0, 0, width, height);
			initPopulation();
			runGeneration(0);		
		},
										  
		growTree: () => {
			grow();
		},

		paint: () => {
			paintTrees();
		}
	};
})();

genetics.start();
</script>