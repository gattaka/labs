<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Babylon Template</title>

    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

    <!--<script src="https://cdn.babylonjs.com/cannon.js"></script>-->
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTFFileLoader.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

</head>

<body>

<canvas id="renderCanvas"></canvas>

<script>
    const canvas = document.getElementById("renderCanvas"); // Get the canvas element
    const engine = new BABYLON.Engine(canvas, true, {
        preserveDrawingBuffer: true,
        stencil: true,
        disableWebGL2Support: false
    });

    const CAMERA_INVERSE_SENSITIVITY = 300;
    const SPEED = 20;
    const SPRINT_SPEED = 50;
    //const PLAYER_JUMP_SPEED = 2000;
    const PLAYER_JUMP_SPEED = 30000;

    const createSkybox = function (scene) {
        var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size: 1000.0}, scene);
        var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        skyboxMaterial.backFaceCulling = false;
        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox/skybox", scene);
        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
        skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        skybox.material = skyboxMaterial;
    };

    const createCamera = function (scene) {
        var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 2, -25), scene);

        // Targets the camera to a particular position. In this case the scene origin
        camera.setTarget(BABYLON.Vector3.Zero());
        // invertní citlivost otáčení kamery (čím vyšší číslo, tím míň se kamera myší otáčí)
        camera.angularSensibility = CAMERA_INVERSE_SENSITIVITY;
        camera.applyGravity = true;
        camera.ellipsoid = new BABYLON.Vector3(.4, .8, .4);
        camera.checkCollisions = true;
        camera.attachControl(canvas, true);

        // nechci, aby pohyb kamery měl vyhlazování
        camera.inertia = 0;

        // This attaches the camera to the canvas
        camera.attachControl(canvas, true);

        return camera;
    };

    const createPlayer = function (scene, camera) {
        let hero = BABYLON.MeshBuilder.CreateBox('hero', {size: 2}, scene);
        hero.position.x = 0.0;
        hero.position.y = 1.0;
        hero.position.z = -5.0;
        hero.physicsAggregate = new BABYLON.PhysicsAggregate(hero, BABYLON.PhysicsShapeType.CAPSULE, {
            mass: 10,
            startAsleep: false,
            restitution: 0.2,
            friction: 0.3
        });
        /*
        hero.physicsAggregate = new BABYLON.PhysicsAggregate(hero, BABYLON.PhysicsShapeType.BOX, {
            mass: 200,
            restitution: 0.2,
            friction: 0.3
        }, scene);
         */

        // pointer
        var pointer = BABYLON.MeshBuilder.CreateSphere("Sphere", {segments: 16.0, diameter: 0.01}, scene);
        pointer.position.x = 0.0;
        pointer.position.y = 0.0;
        pointer.position.z = 0.0;
        pointer.isPickable = false;

        var sprint = false;
        var moveForward = false;
        var moveBackward = false;
        var moveRight = false;
        var moveLeft = false;
        var moveUp = false;

        var onKeyDown = function (event) {
            switch (event.keyCode) {
                case 38: // up
                case 87: // w
                    moveForward = true;
                    break;
                case 37: // left
                case 65: // a
                    moveLeft = true;
                    break;
                case 40: // down
                case 83: // s
                    moveBackward = true;
                    break;
                case 39: // right
                case 68: // d
                    moveRight = true;
                    break;
                case 32: // space
                    hero.physicsAggregate.body.applyForce(new BABYLON.Vector3(0, PLAYER_JUMP_SPEED, 0), hero.getAbsolutePosition());
                    moveUp = true;
                    break;
                case 16: // shift
                    sprint = true;
                    break;
            }
        };

        var onKeyUp = function (event) {
            switch (event.keyCode) {
                case 38: // up
                case 87: // w
                    moveForward = false;
                    break;
                case 37: // left
                case 65: // a
                    moveLeft = false;
                    break;
                case 40: // down
                case 83: // a
                    moveBackward = false;
                    break;
                case 39: // right
                case 68: // d
                    moveRight = false;
                    break;
                case 32: // space
                    moveUp = false;
                    break;
                case 16: // shift
                    sprint = false;
                    break;
            }
        };

        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

        scene.registerBeforeRender(function () {
            camera.position.x = hero.position.x;
            camera.position.y = hero.position.y + 1.0;
            camera.position.z = hero.position.z;
            pointer.position = camera.getTarget();

            var forward = camera.getTarget().subtract(camera.position).normalize();
            forward.y = 0;
            var right = BABYLON.Vector3.Cross(forward, camera.upVector).normalize();
            right.y = 0;

            // rychlost chůze hráče
            let f_speed = 0;
            var s_speed = 0;
            var u_speed = 0;

            var speed = sprint ? SPRINT_SPEED : SPEED;
            if (moveForward) f_speed = speed;
            if (moveBackward) f_speed = -speed;
            if (moveRight) s_speed = -speed;
            if (moveLeft) s_speed = speed;

            // jetpack nebo plavání
            // if (moveUp) u_speed = SPEED;

            var move = (forward.scale(f_speed)).subtract((right.scale(s_speed))).subtract(camera.upVector.scale(u_speed));

            hero.physicsAggregate.body.setGravityFactor(20);
            let y = hero.physicsAggregate.body.getLinearVelocity().y;
            hero.physicsAggregate.body.setLinearVelocity(new BABYLON.Vector3(move.x, y, move.z));
            //hero.physicsAggregate.body.setGravityFactor(1);
        });

        //Mouse
        //We start without being locked.
        var isLocked = false;

        // On click event, request pointer lock
        scene.onPointerDown = function (evt) {
            //true/false check if we're locked, faster than checking pointerlock on each single click.
            if (!isLocked) {
                canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
                if (canvas.requestPointerLock)
                    canvas.requestPointerLock();
            }

            //continue with shooting requests or whatever :P
            //evt === 1 (mouse wheel click (not scrolling))
            //evt === 2 (right mouse click)
        };

        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function () {
            var controlEnabled = document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement || document.pointerLockElement || null;

            // If the user is already locked
            if (!controlEnabled) {
                //camera.detachControl(canvas);
                isLocked = false;
            } else {
                //camera.attachControl(canvas);
                isLocked = true;
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);
    };

    const createScene = async function () {
        // Creates a basic Babylon Scene object
        const scene = new BABYLON.Scene(engine);
        scene.ambientColor = new BABYLON.Color3(1, 1, 1);
        scene.gravity = new BABYLON.Vector3(0, 0, 10);
        scene.collisionsEnabled = true;
        scene.useRightHandedSystem = true; // kvůli GLB importům

        // initialize plugin
        const havokInstance = await HavokPhysics();
        // pass the engine to the plugin
        const hk = new BABYLON.HavokPlugin(true, havokInstance);
        // enable physics in the scene with a gravity
        scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), hk);

        //const sound = new BABYLON.Sound("ambient_nature", "keblov.mp3", scene, null, {loop: true, autoplay: true});

        let camera = createCamera(scene);

        createPlayer(scene, camera);

        // Creates a light, aiming 0,1,0 - to the sky
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        // Dim the light a small amount - 0 to 1
        light.intensity = 0.7;

        // Built-in 'sphere' shape.
        const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2, segments: 4}, scene);
        sphere.position.y = 10;
        sphere.physicsAggregate = new BABYLON.PhysicsAggregate(sphere, BABYLON.PhysicsShapeType.CAPSULE, {
            mass: 100,
            startAsleep: false
        });

        const box = BABYLON.MeshBuilder.CreateBox("box", {}, scene);
        box.position.x = 5;
        box.position.y = 10;
        box.physicsAggregate = new BABYLON.PhysicsAggregate(box, BABYLON.PhysicsShapeType.BOX, {
            mass: 100,
            startAsleep: false
        });

        // Built-in 'ground' shape.
        //const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 60, height: 60}, scene);
        //new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, {mass: 0}, scene);

        var setQuads = function (mesh) {
            quadsReady = true;
            var groundAggregate = new BABYLON.PhysicsAggregate(mesh, BABYLON.PhysicsShapeType.MESH, {mass: 0}, scene);
        };
        var options = {width: 300, height: 300, subdivisions: 200, minHeight: 0, maxHeight: 40, onReady: setQuads, updatable: false};
        var ground = BABYLON.MeshBuilder.CreateGroundFromHeightMap("ground", "textures/heightMap.png", options, scene);
        ground.position.y = -50;

        // https://opengameart.org/content/3-seamless-grass-textures
        let groundMaterialUVScale = 100;
        var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
        groundMaterial.diffuseTexture = new BABYLON.Texture("textures/grass/grass01.jpg", scene);
        groundMaterial.diffuseTexture.uScale = groundMaterialUVScale;
        groundMaterial.diffuseTexture.vScale = groundMaterialUVScale;
        groundMaterial.bumpTexture = new BABYLON.Texture("textures/grass/grass01_n.jpg", scene);
        groundMaterial.bumpTexture.uScale = groundMaterialUVScale;
        groundMaterial.bumpTexture.vScale = groundMaterialUVScale;
        groundMaterial.specularTexture = new BABYLON.Texture("textures/grass/grass01_s.jpg", scene);
        groundMaterial.specularTexture.uScale = groundMaterialUVScale;
        groundMaterial.specularTexture.vScale = groundMaterialUVScale;
        // emissiveTexture ?
        // ambientTexture ?
        ground.material = groundMaterial;

        createSkybox(scene);

        var zidle;

        BABYLON.SceneLoader.ImportMesh("", "models/", "zidle_cervena.glb", scene, (meshes, particleSystems, skeletons) => {
            // do something with the meshes and skeletons
            // particleSystems are always null for glTF assets
            let mainMesh = meshes[0];
            mainMesh.position.y = -2;
            mainMesh.position.z = 0.8;
            mainMesh.position.x = 7.5;

            zidle = BABYLON.MeshBuilder.CreateBox("zidle_cervena.glb_dummyPhysicsRoot", {height: 2}, scene);
            BABYLON.zidle = zidle;
            zidle.addChild(mainMesh);
            // DummyPhysicsRoot Visibility Change to 0 to Hide
            zidle.visibility = 0.7;
            zidle.position.y = -24;
            zidle.position.z = 10;

            zidle.physicsAggregate = new BABYLON.PhysicsAggregate(zidle, BABYLON.PhysicsShapeType.BOX, {
                mass: 100,
                startAsleep: false
            });
        });

        return scene;
    };

    const scene = createScene();

    createScene().then((scene) => {
        engine.runRenderLoop(function () {
            if (scene)
                scene.render();
        });
    });
    // Resize
    window.addEventListener("resize", function () {
        engine.resize();
    });
</script>
</body>
</html>