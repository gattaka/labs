<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Babylon Template</title>

    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

    <!--<script src="https://cdn.babylonjs.com/cannon.js"></script>-->
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTFFileLoader.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

</head>

<body>

<canvas id="renderCanvas"></canvas>

<script>
    const canvas = document.getElementById("renderCanvas"); // Get the canvas element
    const engine = new BABYLON.Engine(canvas, true, {
        preserveDrawingBuffer: true,
        stencil: true,
        disableWebGL2Support: false
    });

    const CAMERA_INVERSE_SENSITIVITY = 400;
    const SPEED = 10;
    const SPRINT_SPEED = 20;
    const PLAYER_JUMP_SPEED = 100000;

    const createSkybox = function (scene) {
        var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size: 1000.0}, scene);
        var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        skyboxMaterial.backFaceCulling = false;
        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox/skybox", scene);
        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
        skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        skybox.material = skyboxMaterial;
    };

    const createCamera = function (scene) {
        var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 2, -25), scene);

        // Targets the camera to a particular position. In this case the scene origin
        camera.setTarget(BABYLON.Vector3.Zero());
        // invertní citlivost otáčení kamery (čím vyšší číslo, tím míň se kamera myší otáčí)
        camera.angularSensibility = CAMERA_INVERSE_SENSITIVITY;
        camera.applyGravity = true;
        camera.ellipsoid = new BABYLON.Vector3(.4, .8, .4);
        camera.checkCollisions = true;
        camera.attachControl(canvas, true);

        // nechci, aby pohyb kamery měl vyhlazování
        camera.inertia = 0;

        // This attaches the camera to the canvas
        camera.attachControl(canvas, true);

        return camera;
    };

    const createPlayer = function (scene, camera) {
        let player = BABYLON.MeshBuilder.CreateBox('player', {size: 2}, scene);
        player.position.x = 0.5;
        player.position.y = -23.0;
        player.position.z = 5.0;
        player.physicsAggregate = new BABYLON.PhysicsAggregate(player, BABYLON.PhysicsShapeType.CAPSULE, {
            mass: 60,
            startAsleep: false,
            restitution: 0, // no bouncing
            friction: 100
        });

        // pointer
        var pointer = BABYLON.MeshBuilder.CreateSphere("Sphere", {segments: 16.0, diameter: 0.01}, scene);
        pointer.position.x = 0.0;
        pointer.position.y = 0.0;
        pointer.position.z = 0.0;
        pointer.isPickable = false;

        var sprint = false;
        var moveForward = false;
        var moveBackward = false;
        var moveRight = false;
        var moveLeft = false;
        var moveUp = false;

        var onKeyDown = function (event) {
            switch (event.keyCode) {
                case 38: // up
                case 87: // w
                    moveForward = true;
                    break;
                case 37: // left
                case 65: // a
                    moveLeft = true;
                    break;
                case 40: // down
                case 83: // s
                    moveBackward = true;
                    break;
                case 39: // right
                case 68: // d
                    moveRight = true;
                    break;
                case 32: // space
                    player.physicsAggregate.body.applyForce(new BABYLON.Vector3(0, PLAYER_JUMP_SPEED, 0), player.getAbsolutePosition());
                    moveUp = true;
                    break;
                case 16: // shift
                    sprint = true;
                    break;
            }
        };

        var onKeyUp = function (event) {
            switch (event.keyCode) {
                case 38: // up
                case 87: // w
                    moveForward = false;
                    break;
                case 37: // left
                case 65: // a
                    moveLeft = false;
                    break;
                case 40: // down
                case 83: // a
                    moveBackward = false;
                    break;
                case 39: // right
                case 68: // d
                    moveRight = false;
                    break;
                case 32: // space
                    moveUp = false;
                    break;
                case 16: // shift
                    sprint = false;
                    break;
            }
        };

        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

        scene.registerBeforeRender(function () {
            camera.position.x = player.position.x;
            camera.position.y = player.position.y + 1.0;
            camera.position.z = player.position.z;
            pointer.position = camera.getTarget();

            var forward = camera.getTarget().subtract(camera.position).normalize();
            forward.y = 0;
            var right = BABYLON.Vector3.Cross(forward, camera.upVector).normalize();
            right.y = 0;

            // rychlost chůze hráče
            let f_speed = 0;
            var s_speed = 0;
            var u_speed = 0;

            var speed = sprint ? SPRINT_SPEED : SPEED;
            if (moveForward) f_speed = speed;
            if (moveBackward) f_speed = -speed;
            if (moveRight) s_speed = -speed;
            if (moveLeft) s_speed = speed;

            // jetpack nebo plavání
            // if (moveUp) u_speed = SPEED;

            var move = (forward.scale(f_speed)).subtract((right.scale(s_speed))).subtract(camera.upVector.scale(u_speed));

            player.physicsAggregate.body.setGravityFactor(20);
            let y = player.physicsAggregate.body.getLinearVelocity().y;
            player.physicsAggregate.body.setLinearVelocity(new BABYLON.Vector3(move.x, y, move.z));
            //hero.physicsAggregate.body.setGravityFactor(1);
        });

        var isLocked = false;
        scene.onPointerDown = function (evt) {
            //true/false check if we're locked, faster than checking pointerlock on each single click.
            if (!isLocked) {
                canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
                if (canvas.requestPointerLock)
                    canvas.requestPointerLock();
            }
        };

        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function () {
            var controlEnabled = document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement || document.pointerLockElement || null;

            // If the user is already locked
            if (!controlEnabled) {
                //camera.detachControl(canvas);
                isLocked = false;
            } else {
                //camera.attachControl(canvas);
                isLocked = true;
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);

        return player;
    };

    const createScene = async function () {
        // Creates a basic Babylon Scene object
        const scene = new BABYLON.Scene(engine);
        scene.ambientColor = new BABYLON.Color3(1, 1, 1);
        scene.gravity = new BABYLON.Vector3(0, 0, 10);
        scene.collisionsEnabled = true;
        scene.useRightHandedSystem = true; // kvůli GLB importům

        // initialize plugin
        const havokInstance = await HavokPhysics();
        // pass the engine to the plugin
        const hk = new BABYLON.HavokPlugin(true, havokInstance);
        // enable physics in the scene with a gravity
        scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), hk);

        //const sound = new BABYLON.Sound("ambient_nature", "keblov.mp3", scene, null, {loop: true, autoplay: true});

        let camera = createCamera(scene);

        let player = createPlayer(scene, camera);

        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
        var hLight = new BABYLON.HemisphericLight("HemisphericLight", new BABYLON.Vector3(0, 1, 0), scene);
        hLight.intensity = 0.4;

        var light = new BABYLON.DirectionalLight("DirectionalLight", new BABYLON.Vector3(0, -1, 0), scene);
        light.position = new BABYLON.Vector3(20, 40, 20);
        // Default intensity is 1. Let's dim the light a small amount
        light.intensity = 0.4;
        light.specular = new BABYLON.Color3(1, 0.76, 0.76);

        // Built-in 'sphere' shape.
        const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2, segments: 4}, scene);
        sphere.position.y = 10;
        sphere.physicsAggregate = new BABYLON.PhysicsAggregate(sphere, BABYLON.PhysicsShapeType.CAPSULE, {
            mass: 100,
            startAsleep: false
        });

        const box = BABYLON.MeshBuilder.CreateBox("box", {}, scene);
        box.position.x = 5;
        box.position.y = 10;
        box.physicsAggregate = new BABYLON.PhysicsAggregate(box, BABYLON.PhysicsShapeType.BOX, {
            mass: 100,
            startAsleep: false
        });

        var setQuads = function (mesh) {
            quadsReady = true;
            var groundAggregate = new BABYLON.PhysicsAggregate(mesh, BABYLON.PhysicsShapeType.MESH, {
                mass: 0,
                restitution: 0,
                friction: 100
            }, scene);
        };
        var options = {
            width: 300,
            height: 300,
            subdivisions: 200,
            minHeight: 0,
            maxHeight: 40,
            onReady: setQuads,
            updatable: false
        };
        var ground = BABYLON.MeshBuilder.CreateGroundFromHeightMap("ground", "textures/heightMap.png", options, scene);
        ground.position.y = -50;

        // https://opengameart.org/content/3-seamless-grass-textures
        let groundMaterialUVScale = 100;
        var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
        groundMaterial.diffuseTexture = new BABYLON.Texture("textures/grass/grass01.jpg", scene);
        groundMaterial.diffuseTexture.uScale = groundMaterialUVScale;
        groundMaterial.diffuseTexture.vScale = groundMaterialUVScale;
        groundMaterial.bumpTexture = new BABYLON.Texture("textures/grass/grass01_n.jpg", scene);
        groundMaterial.bumpTexture.uScale = groundMaterialUVScale;
        groundMaterial.bumpTexture.vScale = groundMaterialUVScale;
        groundMaterial.specularTexture = new BABYLON.Texture("textures/grass/grass01_s.jpg", scene);
        groundMaterial.specularTexture.uScale = groundMaterialUVScale;
        groundMaterial.specularTexture.vScale = groundMaterialUVScale;
        // emissiveTexture ?
        // ambientTexture ?
        ground.material = groundMaterial;

        createSkybox(scene);

        let shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
        shadowGenerator.usePoissonSampling = true;
        shadowGenerator.bias = 0.000001;

        ground.receiveShadows = true;

        var zidle;

        BABYLON.SceneLoader.ImportMesh("", "models/", "zidle.glb", scene, (meshes, particleSystems, skeletons, animationGroup) => {
            meshes.forEach(zidle => {
                //mesh.showBoundingBox = true;
                zidle.setParent(null);
                zidle.position.y = -23;
                zidle.position.z = 10;
                shadowGenerator.getShadowMap().renderList.push(zidle);
                zidle.physicsAggregate = new BABYLON.PhysicsAggregate(zidle, BABYLON.PhysicsShapeType.BOX, {
                    mass: 100,
                    restitution: 0,
                    friction: 50,
                    startAsleep: false
                });
            });
        });

        /*
        var physicsViewer = new BABYLON.Debug.PhysicsViewer(scene);
        for (let mesh of scene.meshes)
            if (mesh.physicsBody)
                physicsViewer.showBody(mesh.physicsBody);
         */

        return scene;
    };

    const scene = createScene();

    createScene().then((scene) => {
        scene.debugLayer.show({
            embedMode: true
        });

        engine.runRenderLoop(function () {
            if (scene)
                scene.render();
        });
    });
    // Resize
    window.addEventListener("resize", function () {
        engine.resize();
    });
</script>
</body>
</html>