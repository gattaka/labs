[N1]Demo[/N1]
[HTML]<table>
	<tbody>
		<tr>
			<td>Function</td>
		</tr>
		<tr>
			<td>	
				<input type="radio" name="func" value="linear" 
					onchange="$.nnet.changeFceLinear()" checked> Linear 
				<input type="radio" name="func" value="sine" 
					onchange="$.nnet.changeFceSine()"> Sine 
				<input type="radio" name="func" value="angle" 
					onchange="$.nnet.changeFceAngle()"> Angle			
			</td>
		</tr>
	</tbody>
</table>
<div style="margin: 10px 0;">
	<canvas id="myCanvas" width="700" height="250"></canvas>
</div>
<div style="margin: 10px 0;">
	<canvas id="netCanvas" width="700" height="500"></canvas>
</div>
<div id="status"></div>[/HTML]
<script>
let $ = {};
$.nnet = (function() {

	/**
	 * https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
	 * https://stackoverflow.com/questions/17433015/change-the-hue-of-a-rgb-color-in-javascript
	 * Converts an HSL color value to RGB. Conversion formula
	 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
	 * Assumes h, s, and l are contained in the set [0, 1] and
	 * returns r, g, and b in the set [0, 255].
	 *
	 * @param   {number}  h       The hue
	 * @param   {number}  s       The saturation
	 * @param   {number}  l       The lightness
	 * @return  {Array}           The RGB representation
	 */
	let hslToRGB = function(h, s, l) {
	    let r, g, b;

	    if (s == 0) {
	        r = g = b = l; // achromatic
	    } else {
	        let hue2rgb = function hue2rgb(p, q, t){
	            if(t < 0) t += 1;
	            if(t > 1) t -= 1;
	            if(t < 1/6) return p + (q - p) * 6 * t;
	            if(t < 1/2) return q;
	            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	            return p;
	        }

	        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        let p = 2 * l - q;
	        r = hue2rgb(p, q, h + 1/3);
	        g = hue2rgb(p, q, h);
	        b = hue2rgb(p, q, h - 1/3);
	    }

	    return "#" + ((1 << 24) + (Math.round(r * 255) << 16) + ( Math.round(g * 255) << 8) + Math.round(b * 255)).toString(16).slice(1);
	};

	let canvas = document.getElementById("myCanvas");
	let ctx = canvas.getContext("2d");
	let width = canvas.width;
	let height = canvas.height;
	let halfWidth = width / 2;
	let halfHeight = height / 2;
	
	let netCanvas = document.getElementById("netCanvas");
	let netCtx = netCanvas.getContext("2d");
	let netWidth = netCanvas.width;
	let netHeight = netCanvas.height;
	let netHalfWidth = netWidth / 2;
	let netHalfHeight = netHeight / 2;
	
	let layerXOffset = 70;
	let layerYOffset = 20;
	let layerNodeRadius = 10;

	let sensitivity = 0.2;
	let bias = 0;
	
	let layersSizes = [5, 7, 6, 4];
	let net = [];
	
	let interval = 1;
	let innerIntervalCallback;
	
	let pointSize = 4;
	
	let triesCount;
	let successCount;
		
	let linearFce = function(x) {				
		return x * height / width;
	};	
	
	let sineFce = function(x) {				
		return Math.sin(Math.PI * x / width) * height;
	};	
			
	let angleFce = function(x) {				
		let widthHalf = width / 2;
		let heightHalf = height / 2;
		if (x < widthHalf)
			return heightHalf;		
		return heightHalf * x / widthHalf; 
	};
	
	let separatorFunc = linearFce;
	
	let transform = function(output) {
		return Math.sign(output);
	};
	
	let guess = function(inputs) {
		let results = [];		
		// pro každou vrstvu
		for (let l = 0; l < net.length; l++) {			
			let netLayer = net[l];		
			// pro každý neuron z vrstvy
			for (let n = 0; n < netLayer.length; n++) {	
				let neuron = netLayer[n];
				let value = 0;
				// pro každý vstup do neuronu
				for (let i = 0; i < inputs.length; i++) 
					value += neuron.weights[i] * inputs[i];	
				results[n] = transform(sum - bias);
			}
			inputs = results;
		}
		return results;
	};
	
	let train = function(inputs, error) {
		for (let i = 0; i < dendriteCount; i++) 
			weights[i] += inputs[i] * error * sensitivity;	
	};
	
	let separator = function(x, y) {
		let fceY = separatorFunc(x);
		return fceY > y ? -1 : 1;
	};
	
	let test = function() {
	
		// náhodně vyber místo
		let x = Math.random() * width;
		let y = Math.random() * height;
		ctx.fillStyle = "black";
		ctx.fillRect(x, y, pointSize, pointSize);
		
		// známá hodnota
		let target = separator(x, y);
		
		// perceptron
		let inputs = [x,y];
		let guessed = guess(inputs);		
		triesCount++;
	
		// učení
		/*
		let error = target - guessed;
		if (error == 0) {
			successCount++;			
			ctx.fillStyle = guessed > 0 ? "#e5ff0f" : "orange";
		} else {
			ctx.fillStyle = "black";
			train(inputs, error);			
		}	
		*/		
		
		let status = "Try = " + triesCount + "<br/>"
			+ "Success rate = " + Math.floor((successCount / triesCount) * 100) + " %";
		for (let i = 0; i < dendriteCount; i++) 
				status += "<br/>w<sub>" + i + "</sub> = " + weights[i];
			document.getElementById("status").innerHTML = status;
		
		ctx.fillRect(x, y, pointSize, pointSize);		
	};

	let innnerChangeInterval = function(value) {
		if (isNaN(value))
			return;
		let newValue = Number(value);
		if (newValue < 1)
			return;
		console.log("interval changed from '" + interval + "' to '" + newValue + "'");
		interval = newValue;
		
		if (innerIntervalCallback) 
			clearInterval(innerIntervalCallback);
		
		innerIntervalCallback = setInterval(function() {
			test();
		}, interval);
	};
	
	let drawNet = function() {
		netCtx.strokeStyle = "black";	
		for (let l = 0; l < layersSizes.length; l++) {
			let layerSize = layersSizes[l]; 			
			// pro každý neuron z vrstvy
			for (let n = 0; n < layerSize; n++) {
				let x = layerXOffset * (l + 1);
				let y = netHeight / 2 + (n - layerSize / 2) * (layerYOffset + layerNodeRadius * 2);
				if (l > 0) {
					let inputSize = layersSizes[l - 1];
					let ix = x - layerXOffset;					
					// pro každý vstup do neuronu
					for (let i = 0; i < inputSize; i++) {
						let iy = netHeight / 2 + (i - inputSize / 2) * (layerYOffset + layerNodeRadius * 2);
						netCtx.beginPath();
						netCtx.moveTo(ix, iy);
						netCtx.lineTo(x, y);
						netCtx.stroke();
					}
				}
			}			
		}
		for (let l = 0; l < layersSizes.length; l++) {
			netCtx.strokeStyle = "black";
			netCtx.fillStyle = hslToRGB(l / layersSizes.length, 1, 0.5);
			let layerSize = layersSizes[l]; 			
			let x = layerXOffset * (l + 1);
			// pro každý neuron z vrstvy
			for (let n = 0; n < layerSize; n++) {				
				let y = netHeight / 2 + (n - layerSize / 2) * (layerYOffset + layerNodeRadius * 2);
				netCtx.beginPath();
				netCtx.arc(x, y, layerNodeRadius, 0, Math.PI * 2);
				netCtx.stroke();
				netCtx.fill();
			}			
		}
	};

	let init = function() {
		triesCount = 0;			
		successCount = 0;
	
		// net init
		// pro každou vrstvu
		for (let l = 1; l < layersSizes.length; l++) {
			let layer = [];
			net.push(layer);
			let inputSize = layersSizes[l - 1];
			let layerSize = layersSizes[l]
			// pro každý neuron z vrstvy
			for (let n = 0; n < layerSize; n++) {	
				let weights = [];
				// pro každý vstup do neuronu
				for (let i = 0; i < inputSize; i++) 
					weights.push(Math.random >= 0.5 ? 1 : -1);
				layer[n] = {
					weights: weights
				}
			}
		}

		// plocha1 funkce 	
		ctx.clearRect(0, 0, width, height);			
		ctx.strokeStyle = "grey";
		ctx.fillStyle = "grey";
		ctx.strokeRect(0, 0, width, height);		
						
		// vykresli oddělovač funkce
		for (let x = 0; x < width; x++) 
			ctx.fillRect(x, separatorFunc(x), 1, 1);
		
		netCtx.clearRect(0, 0, netWidth, netHeight);			
		netCtx.strokeStyle = "lightgrey";
		netCtx.fillStyle = "grey";
		netCtx.strokeRect(0, 0, netWidth, netHeight);

		// vykresli neuronovou síť
		drawNet();

		//innnerChangeInterval(interval);	
	};

	return {
	
		start: function() {			
			init();			
		},
		
		changeFceLinear: function() {
			separatorFunc = linearFce;	
			init();
		},
		
		changeFceSine: function() {
			separatorFunc = sineFce;	
			init();
		},
		
		changeFceAngle: function() {
			separatorFunc = angleFce;	
			init();
		}
		
	};

})();

$.nnet.start();
</script>