[N1]Demo[/N1]
[HTML]<table>
	<tbody>
		<tr>
			<td>Function</td>
		</tr>
		<tr>
			<td>	
				<input type="radio" name="func" value="linear" 
					onchange="$.nnet.changeFceLinear()" checked> Linear 
				<input type="radio" name="func" value="sine" 
					onchange="$.nnet.changeFceSine()"> Sine 
				<input type="radio" name="func" value="angle" 
					onchange="$.nnet.changeFceAngle()"> Angle			
			</td>
		</tr>
	</tbody>
</table>
<div style="margin: 10px 0;">
	<canvas id="myCanvas" width="700" height="250"></canvas>
</div>
<div style="margin: 10px 0;">
	<canvas id="netCanvas" width="700" height="500"></canvas>
</div>
<div id="status"></div>[/HTML]
<script>
let $ = {};
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
// https://stackoverflow.com/questions/32647215/declaring-static-constants-in-es6-classes
$.Matrix = class Matrix {

	#rows = 0;
	#cols = 0;
	#data = [];
	
	static checkDefined(o, err) {
		if (typeof o === 'undefined')
			throw err + " is undefined";
	}
	
	static checkDefinedNumber(o, err) {
		Matrix.checkDefined(o, err);
		if (typeof o != 'number')
			throw err + " is not a number";
	}
	
	static checkDefinedPositiveInteger(o, err) {
		Matrix.checkDefinedNumber(o, err);
		if (!Number.isInteger(o))
			throw err + " is not an integer";
		if (o < 0)
			throw err + " is must be positive integer";
	}
	
	static checkMatrixInstance(m) {
		if (!(m instanceof Matrix)) 
			throw "Not a Matrix instance";
	}		
	
	static createIdentity(dimension) {
		Matrix.checkDefinedPositiveInteger(dimension, "dimension");
		let matrix = new Matrix(dimension, dimension);
		for (let i = 0; i < dimension; i++)
			matrix.set(i, i, 1);
		return matrix;
	}
	
	static fromFlatArray(rows, cols, array) {
		if (typeof array != 'object')
			throw "Not a Matrix instance";		
		let matrix = new Matrix(rows, cols);
		let i = 0;
		for (let r = 0; r < rows; r++) {
			for (let c = 0; c < cols; c++) {
				Matrix.checkDefinedNumber(array[i], "element [" + r + "," + c + "]");
				matrix.set(r,c, array[i++]);
			}
		}
		return matrix;
	}
	
	constructor(rows, cols) {
		Matrix.checkDefinedPositiveInteger(rows, "rows");
		Matrix.checkDefinedPositiveInteger(cols, "cols");	
		this.#rows = rows;
		this.#cols = cols;
		// indexově jsou nejprve řádky, pak sloupce		
		for (let r = 0; r < rows; r++) {
			let row = [];
			this.#data[r] = row;
			for (let c = 0; c < cols; c++) 
				row[c] = 0;
		}
	}
	
	checkDimensions(row, col) {
		Matrix.checkDefinedPositiveInteger(row, "row");
		Matrix.checkDefinedPositiveInteger(col, "col");
		if (row > this.#rows - 1 || row < 0) throw "Invalid row number (0-" + (this.#rows - 1) + ")";
		if (col > this.#cols - 1 || col < 0) throw "Invalid col number (0-" + (this.#cols - 1) + ")";
	}
	
	print() {
		//console.table(this.#data);
		let line = '';
		for (let r = 0; r < this.#rows; r++) {
			line += r == 0 ? '┌\t' : (r == this.#rows - 1 ? '└\t' : '│\t');
			for (let c = 0; c < this.#cols; c++) {
				line += this.get(r,c) + '\t';
				if (c == this.#cols - 1) {
					line += r == 0 ? '┐' : (r == this.#rows - 1 ? '┘' : '│');
					console.log(line);
					line = '';
				}
			}
		}		
	}
	
	getRows() {
		return this.#rows;
	}
	
	getCols() {
		return this.#cols;
	}
		
	get(row, col) {
		this.checkDimensions(row, col);		
		return this.#data[row][col];
	}
	
	set(row, col, value) {
		this.checkDimensions(row, col);	
		Matrix.checkDefinedNumber(value, "value");
		this.#data[row][col] = value;
	}
	
	add(m) {
		Matrix.checkMatrixInstance(m);		
		if (m.getRows() != this.#rows)
			throw "A and B has different number of rows";
		if (m.getCols() != this.#cols)
			throw "A and B has different number of rows";
		let result = new Matrix(this.#rows, this.#cols);
		for (let r = 0; r < this.#rows; r++)			
			for (let c = 0; c < this.#cols; c++)
				result.set(r, c, this.get(r, c) + m.get(r, c));
		return result;				
	}
	
	subtract(m) {
		let m2 = m.multiplyByScalar(-1);
		return this.add(m2);
	}
	
	addScalar(n) {
		Matrix.checkDefinedNumber(n, "value");
		let result = new Matrix(this.#rows, this.#cols);
		for (let r = 0; r < this.#rows; r++)			
			for (let c = 0; c < this.#cols; c++)
				result.set(r, c, this.get(r, c) + n);
		return result;				
	}
	
	multiply(m) {
		Matrix.checkMatrixInstance(m);		
		if (m.getRows() != this.getCols())
			throw "A.B requires A.cols = B.rows";
		let result = new Matrix(this.getRows(), m.getCols());
		for (let r = 0; r < result.getRows(); r++) {
			for (let c = 0; c < result.getCols(); c++) {
				let sum = 0;
				for (let i = 0; i < this.getCols(); i++)
					sum += this.get(r, i) * m.get(i, c);
				result.set(r, c, sum);
			}
		}			
		return result;	
	}
	
	multiplyHadamard(m) {
		Matrix.checkMatrixInstance(m);		
		if (m.getRows() != this.getRows())
			throw "A.B requires A.rows = B.rows";
		if (m.getCols() != this.getCols())
			throw "A.B requires A.cols = B.cols";
		let result = new Matrix(this.getRows(), this.getCols());
		for (let r = 0; r < result.getRows(); r++)
			for (let c = 0; c < result.getCols(); c++)
				result.set(r, c, this.get(r, c) * m.get(r, c));	
		return result;	
	}
	
	multiplyByScalar(n) {
		Matrix.checkDefinedNumber(n, "value");
		let result = new Matrix(this.#rows, this.#cols);
		for (let r = 0; r < this.#rows; r++)			
			for (let c = 0; c < this.#cols; c++)
				result.set(r, c, this.get(r, c) * n);
		return result;				
	}
	
	map(func) {
		let result = new Matrix(this.#rows, this.#cols);
		for (let r = 0; r < this.#rows; r++)			
			for (let c = 0; c < this.#cols; c++)
				result.set(r, c, func(this.get(r, c)));
		return result;
	}
	
	transpose() {		
		let result = new Matrix(this.getCols(), this.getRows());
		for (let r = 0; r < this.getRows(); r++)
			for (let c = 0; c < this.getCols(); c++) 
				result.set(c, r, this.get(r, c));
		return result;
	}
};

$.nnet = (function() {

	/**
	 * https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
	 * https://stackoverflow.com/questions/17433015/change-the-hue-of-a-rgb-color-in-javascript
	 * Converts an HSL color value to RGB. Conversion formula
	 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
	 * Assumes h, s, and l are contained in the set [0, 1] and
	 * returns r, g, and b in the set [0, 255].
	 *
	 * @param   {number}  h       The hue
	 * @param   {number}  s       The saturation
	 * @param   {number}  l       The lightness
	 * @return  {Array}           The RGB representation
	 */
	let hslToRGB = function(h, s, l) {
	    let r, g, b;

	    if (s == 0) {
	        r = g = b = l; // achromatic
	    } else {
	        let hue2rgb = function hue2rgb(p, q, t){
	            if(t < 0) t += 1;
	            if(t > 1) t -= 1;
	            if(t < 1/6) return p + (q - p) * 6 * t;
	            if(t < 1/2) return q;
	            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	            return p;
	        }

	        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        let p = 2 * l - q;
	        r = hue2rgb(p, q, h + 1/3);
	        g = hue2rgb(p, q, h);
	        b = hue2rgb(p, q, h - 1/3);
	    }

	    return "#" + ((1 << 24) + (Math.round(r * 255) << 16) + ( Math.round(g * 255) << 8) + Math.round(b * 255)).toString(16).slice(1);
	};

	let canvas = document.getElementById("myCanvas");
	let ctx = canvas.getContext("2d");
	let width = canvas.width;
	let height = canvas.height;
	let halfWidth = width / 2;
	let halfHeight = height / 2;
	
	let netCanvas = document.getElementById("netCanvas");
	let netCtx = netCanvas.getContext("2d");
	let netWidth = netCanvas.width;
	let netHeight = netCanvas.height;
	let netHalfWidth = netWidth / 2;
	let netHalfHeight = netHeight / 2;
	
	let layerXOffset = 70;
	let layerYOffset = 20;
	let layerNodeRadius = 10;
	let layerNodesOffset = layerYOffset + layerNodeRadius * 2;

	let sensitivity = 0.2;
	
	let layersSizes = [2, 1];
	// pole matic vah dle vrstvy
	let weights = [];
	// pole vektorů biasů dle vrstvy
	let biases = [];
	// pole vektorů potenciálů dle vrstvy
	let potentials = [];
	// pole vektorů aktivací dle vrstvy
	let activations = [];
	// pole vektorů chyb dle vrstvy
	let errors = [];
	
	let interval = 1;
	let innerIntervalCallback;
	
	let pointSize = 4;
	
	let triesCount;
	let successCount;		
		
	let drawLines = function() {
		netCtx.strokeStyle = "black";	
		for (let l = 0; l < layersSizes.length; l++) {
			let layerSize = layersSizes[l]; 			
			// pro každý neuron z vrstvy
			for (let n = 0; n < layerSize; n++) {
				let x = layerXOffset * (l + 1);
				let y = netHalfHeight + (n - layerSize / 2) * layerNodesOffset;
				if (l > 0) {
					let inputSize = layersSizes[l - 1];
					let ix = x - layerXOffset;					
					// pro každý vstup do neuronu
					for (let i = 0; i < inputSize; i++) {
						let iy = netHalfHeight + (i - inputSize / 2) * layerNodesOffset;
						netCtx.beginPath();
						netCtx.moveTo(ix, iy);
						netCtx.lineTo(x, y);
						netCtx.stroke();
					}
				}
			}			
		}
	};
	
	let drawNodes = function() {
		for (let l = 0; l < layersSizes.length; l++) {
			netCtx.strokeStyle = "black";
			netCtx.fillStyle = hslToRGB(l / layersSizes.length, 1, 0.5);
			let layerSize = layersSizes[l]; 			
			let x = layerXOffset * (l + 1);
			// pro každý neuron z vrstvy
			for (let n = 0; n < layerSize; n++) {				
				let y = netHalfHeight + (n - layerSize / 2) * layerNodesOffset;
				netCtx.beginPath();
				netCtx.arc(x, y, layerNodeRadius, 0, Math.PI * 2);
				netCtx.stroke();
				netCtx.fill();
			}			
		}
	};
	
	let drawNet = function() {
		drawLines();
		drawNodes();
	};
		
	let linearFce = function(x) {				
		return x * height / width;
	};	
	
	let sineFce = function(x) {				
		return Math.sin(Math.PI * x / width) * height;
	};	
			
	let angleFce = function(x) {				
		let widthHalf = width / 2;
		let heightHalf = height / 2;
		if (x < widthHalf)
			return heightHalf;		
		return heightHalf * x / widthHalf; 
	};
	
	let separatorFunc = linearFce;	
		
	let separator = function(x, y) {
		let fceY = separatorFunc(x);
		return fceY > y ? 0 : 1;
	};
	
	let activationFunc = function(x) {
		return 1 / (1 + Math.pow(Math.E, -x));
	};
	
	let activationDerFunc = function(x) {
		return activationFunc(x) * (1 - activationFunc(x));
	};
	
	let test = function() {
	
		// náhodně vyber místo
		let x = Math.random() * width;
		let y = Math.random() * height;
		ctx.fillStyle = "black";
		ctx.fillRect(x, y, pointSize, pointSize);
		
		// sloupcový vektor vstupů
		let inputs = $.Matrix.fromFlatArray(2, 1, [x, y]);
		// sloupcový vektor známé hodnoty výstupu
		let target = $.Matrix.fromFlatArray(1, 1, [separator(x, y)]);
		
		// potenciály a aktivace
		activations[0] = inputs;
		for (let l = 1; l < layersSizes.length; l++) {
			// z^l = w^l . a^(l-1) + b^l
			potentials[l] = weights[l].multiply(activations[l - 1]).add(biases[l]);
			// a^l = sigma(z^l)
			activations[l] = potentials[l].map(activationFunc);
		}
		
		// chyba výsledné vrstvy
		let L = layersSizes.length - 1;
		for (let l = L; l > 0; l--) {
			if (l == L) {
				// delta^L = (a^L - y) o sigma'(z^L)
				errors[l] = activations[l].subtract(target).multiplyHadamard(potentials[l].map(activationDerFunc));
			} else {
				// delta^l = ((w^(l+1))^T . delta^(l+1)) o sigma'(z^L)
				errors[l] = weights[l+1].transpose().multiply(errors[l+1]).multiplyHadamard(potentials[l].map(activationDerFunc));
			}
		}
		
		triesCount++;
	
		let overallError = 0;
		for (let j = 0; j < layersSizes[L]; j++)
			overallError += Math.abs(errors[L].get(j, 0));
		overallError /= layersSizes[L];
	
		// učení
		if (overallError < 0.1) {
			successCount++;			
			ctx.fillStyle = activations[L].get(0, 0) > 0 ? "#e5ff0f" : "orange";
		} else {
			ctx.fillStyle = "black";
			// aktualizuj váhy a biasy
			for (let l = L; l > 0; l--) {
				// Projdi neurony na vrstvě
				for (let j = 0; j < layersSizes[l]; j++) {
					// Projdi jejich váhy
					for (let k = 0; k < weights[l].getCols(); k++) {
						weights[l].set(j, k, weights[l].get(j, k) - activations[l-1].get(j, 0) * errors[l].get(j, 0));
					}
					biases[l].set(j, 0, biases[l].get(j, 0) - errors[l].get(j, 0));
				}
			}
		}			
		
		let status = "Try = " + triesCount + "<br/>"
			+ "Success rate = " + Math.floor((successCount / triesCount) * 100) + " %";	
		document.getElementById("status").innerHTML = status;
		
		ctx.fillRect(x, y, pointSize, pointSize);		
	};

	let innnerChangeInterval = function(value) {
		if (isNaN(value))
			return;
		let newValue = Number(value);
		if (newValue < 1)
			return;
		console.log("interval changed from '" + interval + "' to '" + newValue + "'");
		interval = newValue;
		
		if (innerIntervalCallback) 
			clearInterval(innerIntervalCallback);
		
		innerIntervalCallback = setInterval(function() {
			test();
		}, interval);
	};

	let init = function() {
		triesCount = 0;			
		successCount = 0;
	
		// Matice vah -- pro každý neuron vrstvy jsou 
		// zapsány váhy neuronů (co řádek, to jeden neuron)
		// pokud pak matici vynásobím maticí vstupů
		// projdou se postupně sloupce matice (vstupy neuronu)
		// a provede se součet součinů jeho vah a vstupů
		//	
		//	| w11 w12 w13 |   | x1 |       | w11x1 + w12x2 + w13x3 |   | b1 |
		//  | w21 w22 w23 | . | x2 | + B = | w21x1 + w22x2 + w23x3 | + | b2 |
		//                    | x3 |   
		
		// net init
		// pro každou vrstvu (kromě 0. ta indikuje pouze počet vstupů)
		for (let l = 1; l < layersSizes.length; l++) {
			let inputSize = layersSizes[l - 1];
			let layerSize = layersSizes[l]
			let layerWeights = new $.Matrix(layerSize, inputSize);
			// sloupcový vektor
			let layerBiases = new $.Matrix(layerSize, 1);
			weights[l] = layerWeights;
			biases[l] = layerBiases;			
			// pro každý neuron z vrstvy
			for (let row = 0; row < layerSize; row++) {	
				// pro každý vstup do neuronu
				for (let col = 0; col < inputSize; col++) 
					layerWeights.set(row, col, Math.random >= 0.5 ? 1 : -1);
				layerBiases.set(row, 0, Math.random >= 0.5 ? 1 : -1);
			}
		}

		// plocha funkce 	
		ctx.clearRect(0, 0, width, height);			
		ctx.strokeStyle = "grey";
		ctx.fillStyle = "grey";
		ctx.strokeRect(0, 0, width, height);		
						
		// vykresli oddělovač funkce
		for (let x = 0; x < width; x++) 
			ctx.fillRect(x, separatorFunc(x), 1, 1);
		
		netCtx.clearRect(0, 0, netWidth, netHeight);			
		netCtx.strokeStyle = "lightgrey";
		netCtx.fillStyle = "grey";
		netCtx.strokeRect(0, 0, netWidth, netHeight);

		// vykresli neuronovou síť
		drawNet();

		innnerChangeInterval(interval);	
	};

	return {
	
		start: function() {			
			init();			
		},
		
		changeFceLinear: function() {
			separatorFunc = linearFce;	
			init();
		},
		
		changeFceSine: function() {
			separatorFunc = sineFce;	
			init();
		},
		
		changeFceAngle: function() {
			separatorFunc = angleFce;	
			init();
		}
		
	};

})();

$.nnet.start();
</script>