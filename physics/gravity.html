<head>
	<script type="text/javascript" src="../libs/colors.js"></script>
</head>

[N1]Demo[/N1]
[HTML]<div style="margin: 10px 0;display: inline-block;">
	<canvas id="myCanvas" width="700" height="300"></canvas>
</div>
[/HTML]
<script>
var $ = $ || {};
$.gravity = (function() {

	let canvas = document.getElementById("myCanvas");
	let ctx = canvas.getContext("2d");
	let width = canvas.width;
	let height = canvas.height;
	let halfWidth = width / 2;
	let halfHeight = height / 2;

	let interval = 1;
	let innerIntervalCallback;

	let timeStep = 1;
	let gravity = 0.02;
	let absorption = 0.2;
	let friction = 0.0001;
	let ballMass = 10;
	let ballRadius = 10;		

	let ballCount = 100;
	let balls = [];
	
	let minSpeed = 0.05;
			
	let processY = function(ball, timeDelta) {
		// s_t = v_0 . dt + 1/2 a . dt^2
		let newY = ball.y + ball.sy * timeDelta + 0.5 * gravity * timeDelta * timeDelta;
		let topHit = newY - ballRadius < 0;
		let bottomHit = newY + ballRadius > height;
		if (topHit || bottomHit) {
			// zbývající dráha do kolize se stěnou
			let restY = bottomHit ? height - (ball.y + ballRadius) : ball.y - ballRadius;
			// zbývající čas do kolize se stěnou
			let directionKoef = bottomHit ? 1 : -1;
			let restTime = Math.abs((-ball.sy + directionKoef * Math.sqrt(ball.sy * ball.sy + 2 * gravity * restY)) / gravity);
			// rychlost v čase odrazu
			ball.sy = -(ball.sy * (1 - absorption) + restTime * gravity);
			if (Math.abs(ball.sy) < minSpeed) {
				ball.sy = 0;
				ball.y = bottomHit ? height - ballRadius : ballRadius;
			} else {
				// dopočítej vzdálenost odrazu za zbytek časového kroku, který byl rozložen na dopad a odraz
				let timeBack = timeDelta - restTime;
				processY(ball, timeBack);
			}
		} else {
			ball.sy += gravity * timeDelta;
			ball.y = newY;
		}
	};
	
	let processX = function(ball, timeDelta) {
		let newX = ball.x + ball.sx * timeDelta;
		let rightHit = newX + ballRadius > width;
		let leftHit = newX - ballRadius < 0;
		if (leftHit || rightHit) {
			// zbývající dráha do kolize se stěnou
			let restX = rightHit ? width - (ball.x + ballRadius) : ball.x - ballRadius;
			// zbývající čas do kolize se zemí
			let restTime = Math.abs(restX / ball.sx);
			ball.sx = -ball.sx * (1 - absorption);
			if (Math.abs(ball.sx) < minSpeed) {
				ball.sx = 0;
				ball.x = rightHit ? width - ballRadius : ballRadius;
			} else {
				// dopočítej vzdálenost odrazu za zbytek časového kroku, který byl rozložen na dopad a odraz
				let timeBack = timeDelta - restTime;
				processX(ball, timeBack);
			}
		} else {
			ball.x = newX;
			if (ball.y == height - ballRadius)
				ball.sx -= Math.sign(ball.sx) * friction * timeDelta;
		}
	};
			
	let step = function() {
		// plocha 	
		ctx.clearRect(0, 0, width, height);			
		ctx.strokeStyle = "grey";
		ctx.fillStyle = "grey";
		ctx.strokeRect(0, 0, width, height);	
			
		for (let i = 0; i < balls.length; i++) {
			let ball = balls[i];
			processY(ball, timeStep);
			processX(ball, timeStep);
			ctx.fillStyle = ball.c;			
			ctx.beginPath();
			ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
			ctx.fill();
		}


	};

	let innnerChangeInterval = function(value) {
		if (isNaN(value))
			return;
		let newValue = Number(value);
		if (newValue < 1)
			return;
		console.log("interval changed from '" + interval + "' to '" + newValue + "'");
		interval = newValue;
		
		if (innerIntervalCallback) 
			clearInterval(innerIntervalCallback);
		
		innerIntervalCallback = setInterval(function() {
			step();
		}, interval);
	};

	let init = function() {	
		for (let i = 0; i < ballCount; i++) {
			balls.push({
				c: $.GJSLibColors.hslToRGB(i / ballCount, 1, 0.5),
				x: ballRadius + Math.random() * (width - 2 * ballRadius),
				y: ballRadius + Math.random() * (height - 2 * ballRadius),
				sx: 5 - Math.random() * 10,
				sy: 5 - Math.random() * 10
			});
		}
	
		innnerChangeInterval(interval);	
	};

	return {
	
		start: function() {			
			init();
		},
		
	};

})();

$.gravity.start();
</script>